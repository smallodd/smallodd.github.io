{"pages":[{"title":"分类","text":"title: 文章分类date: 2017-05-27 13:47:40 type: “categories”","link":"/categories/index.html"},{"title":"程振奇 | smallodd","text":"关于我 喜欢交友,心态乐观 不会惹事,也不怕事 善于学习,勤于思考 经历 15年软件技术毕业,参加工作,主要做java开发 现在在公司做服务端技术架构,带人,任务分配 爱号 技术交流(其实就是水O(∩_∩)O哈哈~) 看动漫 养生(生活还是需要一些养生的)","link":"/about/index.html"},{"title":"我的标签云","text":"","link":"/tags/index.html"}],"posts":[{"title":"一起学Linux之 shell脚本的服务封装","text":"前言在使用springboot的过程中由于大多数使用的是springboot自带的tomcat，所以启动方式为 java -jar xxx.jar 但是这样启动不好维护，故而需要写一个脚本来维护。 启动脚本废话不多bb，直接上脚本，内容如下： [] [tomcat.sh]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#! /bin/bash# jar包位置APP_NAME=/xxx/xx/xxx.jar#使用说明，用来提示输入参数usage() { echo \"Usage: sh 执行脚本.sh [start|stop|restart|status]\" exit 1}#检查程序是否在运行is_exist(){ pid=`ps -ef|grep $APP_NAME|grep -v grep|awk '{print $2}' ` #如果不存在返回1，存在返回0 if [ -z \"${pid}\" ]; then return 1 else return 0 fi}#启动方法start(){ is_exist if [ $? -eq \"0\" ]; then echo \"${APP_NAME} is already running. pid=${pid} .\" else nohup /usr/local/jdk1.8/bin/java -jar $APP_NAME | /usr/local/sbin/cronolog ./logs/catalina-%Y-%m-%d.out 2&gt;&amp;1 &amp; fi}#停止方法stop(){ is_exist if [ $? -eq \"0\" ]; then kill -9 $pid else echo \"${APP_NAME} is not running\" fi }#输出运行状态status(){ is_exist if [ $? -eq \"0\" ]; then echo \"${APP_NAME} is running. Pid is ${pid}\" else echo \"${APP_NAME} is NOT running.\" fi}#重启restart(){ stop start}#根据输入参数，选择执行对应方法，不输入则执行使用说明case \"$1\" in \"start\") start ;; \"stop\") stop ;; \"status\") status ;; \"restart\") restart ;; *) usage ;;esac 其中cronolog 是一个log切割工具 防止log文件过大的问题。 封装成服务经过上述操作，我们的shell脚本就写好了，写完只需要像执行tomcat中的脚本一样执行这个脚本就可以了。但是这个脚本还有一个问题，那就是运行一次就很棒，但是服务器重启，我们就要手动运行一次，所以我们要开机自启。如何开机自启呢，就需要一个系统服务了。如何封装系统服务呢 ok 请看如下操作： 进入 centos7 中的/usr/lib/systemd/system 文件夹 新建xxx.service文件，文件内容如下 [] [xxx.service]123456789101112131415[Unit]Description=描述#这个不用变，是启动顺序After=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingWorkingDirectory=/xxx/xxExecStart=/xxx/xx/bin/service.sh startExecReload=/xxx/xx/bin/service.sh restartExecStop=/xxx/xx/bin/service.sh stopPrivateTmp=true[Install]WantedBy=multi-user.target 经过上述步骤 我们就新建了一个叫xxx.service 的系统服务，就可以用 services xxx start 启动了，现在只需要把他加入到开机自启里面就可以了，只需要systemctl enable xxx来开启开机自启就可以了，以上就是关于本篇文章的全部内容，另外本文主要描述如何对shell脚本进行服务封装，并非仅仅针对springboot。希望需要帮助到大家","link":"/3194397260.html"},{"title":"一起来学maven之nexus私服的搭建","text":"前言本文假定你知道什么是maven，这里不做过多的阐述，如果有兴趣的话可以尝试看一下maven实战这本书，由于maven的国外仓库贼慢，加上有些自己封装的工具包不能直接放到中央仓库上，所以就有了搭建maven私服的需求，那么我们如何搭建呢？下面我们一起了解一下。 准备 nexus，我们使用nexus，版本为2.14.17，我们不使用nexus3.x原因是因为nexus3.x如何同步主仓库的索引，如果有知晓的大大，可以评论区告知一下，不胜感激。点我下载nexus jdk1.8，这个没得选，建议jdk1.8 系统要求看公司的要求一般公司建议8核16g。注意： 请不要使用root用户允许nexus，所以需要新建一个用户nexus nexus用户打开的文件描述符的数量限制增加到65,536或更高，centos用户可以通过编辑/etc/security/limits.conf文件来增加限制，在该文件中新增nexus - nofile 65536- nofile 65536 离线索引文件、离线索引配置文件、解压离线索引的jar,离线索引文件、离线索引配置文件以及可以通过https://repo.maven.apache.org/maven2/.index/这个地址来找到。解压离线索引的jar文件可以在https://search.maven.org/这个搜索仓库中搜索org.apache.maven.indexer:indexer-cli:5.1.1然后点击右上角的下载按钮即可 文件 说明 nexus-maven-repository-index.gz 离线索引文件 nexus-maven-repository-index.properties 索引配置文件 安装以及启动 将下载好的文件找一个合适的地方解压，然后会出现俩目录，nexus-2.14.17-01、sonatype-work一个是服务文件夹，一个是存放数据的文件夹 将下载好的离线索引文件、离线索引配置文件、解压离线索引的jar这三个放到同一目录下，然后用命令 java -jar indexer-cli-5.1.0.jar -u nexus-maven-repository-index.gz -d indexer 大概4-5分钟的样子就解压完成了。解压好的文件在同级目录下的indexer文件夹下 将indexer文件夹下的文件复制到${nexus_home}/sonatype-work/nexus/indexer/central-ctx文件夹下 进入${nexus_home}/nexus-2.14.17-01/bin文件夹下，运行nexus start 就可以启动了 防火墙放开8081端口就可以通过内网访问了，如果端口不爽可以通过修改${nexus_home}/nexus-2.14.17-01/conf/nexus.properties文件中的application-port属性来修改端口 记得开机自启、nexus服务的封装。 迁移只需要将nexus-2.14.17-01、sonatype-work俩文件夹打包复制，拷贝到新机器上，然后重启即可","link":"/1297375589.html"},{"title":"一起来玩Jenkins之Jenkins的搭建以及项目的构建","text":"前言在开发完成后，我们都是要将开发好的项目部署到服务器上的，而部署到服务器上的步骤常常是不变的，所以自动化部署是可以实现的，那么如何自动化部署呢？ Jenkins可以解决我们这个问题。下面让我们一起来了解一下。 什么是JenkinsJenkins是开源CI&amp;CD软件领导者， 提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要。 Jenkins功能包括： 持续的软件版本发布/测试项目。 监控外部调用执行的工作。 如何搭建简单的Jenkins环境 需要准备 Jenkins安装包、jdk1.8、tomcat 准备好以后，将Jenkins安装包放入tomcat中的webapps中启动tomcat即可 浏览器访问端口根据提示找到密码文件，并输入密码文件中的密码以后我们就可以进入到Jenkins的主页面了 如果不想汉化的，请忽略此步骤。 点击左侧的Manage Jenkins。 点击Manage Plugins 点击第二个选项卡(可选插件)，搜索local找到Localization: Chinese (Simplified)插件安装，并重启Jenkins，这样我们就汉化完成了 如何使用Jenkins我们搭建好简单的环境后就一起来了解一下如何使用，下面我们将通过构建git上存储的maven项目来实际操作一下。 准备工作: 在Jenkins服务器上搭建好git环境用来拉取git上的代码。准备好maven环境来对项目进行编译。 Jenkins所需插件的安装 Git Parameter Plug-In、Git plugin、SSH plugin、Publish Over SSH、Maven Integration plugin 注意：安装过程中可能会出现timeout的异常，原因是因为国外的插件库不稳定造成的需要更换地址，更换方式为： Manage Jenkins—&gt;Manage Plugins—&gt;高级—&gt;最底部—&gt;修改升级站点。可以修改为的站点有： 12345http://mirror.xmission.com/jenkins/updates/update-center.jsonhttp://mirror.esuni.jp/jenkins/updates/update-center.jsonhttps://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 一个一个试试，总有一个适合你。笔者用的是第三个，清华大学的镜像 Jenkins所在服务器生成私钥，部署服务器上存储公钥，用于Jenkins的远程免密拷贝文件。具体步骤如下 Jenkins服务器使用命令ssh-keygen -t rsa 然后回车三下，生成私钥，这条命令会在~目录下生成一个.ssh的文件夹。里面文件的含义分别是： id_rsa: 生成的私钥文件 id_rsa.pub: 生成的公钥文件 know_hosts: 已知的主机公钥清单 通过sh-copy-id将公钥写入远程服务器中具体命令为：ssh-copy-id root@192.168.199.129 Jenkins系统配置依次点击 Manage Jenkins—&gt;Configure System 找到Publish over SSH 在Key字段中写写入Jenkins部署服务器中生成好的私钥 新增ssh 服务器，这个可以新增多个，其中Remote Directory字段表示以后拷贝到远程服务器上面的根文件夹是什么。 Jenkins全局配置依次点击 Manage Jenkins—&gt;Global Tool Configuration 新增jdk 新增git 新增maven 新建任务 点击左侧的新建Item进入如图页面，输入名称，选择构建一个maven项目，也可以复制一个之前已经配置好的项目。进入如图 选择的是Discard old builds(丢弃旧的构建,也可不选)，如图 选择This project is parameterized—&gt;添加参数—&gt;Git Parameter 填入如图数据，描述随便写，名称最好见名知意，因为下面会用到 源码管理选择git，Repository URL输入你的项目的git地址(http形式的)，点击添加，选择Jenkins 添加git凭据，用户名输入git账户，密码输入git密码，id可以不写，描述随便写 指定分支输入$加上Git Parameter中的名称，例如我的名称是breach那么这里就写$breach 建立环境中在目标和选择里面写入maven命令，注意不需要加mvn，发布步骤选择仅在构建成功时运行 构建后操作，如图其中Source files表示构建完成后目标文件夹Remove prefix拷贝时不需要拷贝的文件夹Remote directory表示移动的目录，和全局配置中的组合一起，即为最终目录Exec command表示要执行的命令。其中脚本为 12345678910111213141516#!/bin/bash#定义一些常用变量log_time=`date +%Y-%m-%d_%H:%M:%S`tomcat_home=/opt/tomcat80web_backup_home=/root/webbak/lbrz-admin-$log_timewar_base_home=/opt/hachi-lbrz#停止服务，并备份文件echo &quot;********************************** 开始停止服务并备份文件`date +%Y-%m-%d_%H:%M:%S`*************************************&quot;/opt/tomcat80/bin/shutdown.shmkdir -p $web_backup_homemv $tomcat_home/webapps/ROOT* $web_backup_homeecho &quot;************************备份完成`date +%Y-%m-%d_%H:%M:%S` **********************************&quot;echo &quot;************************准备启动服务`date +%Y-%m-%d_%H:%M:%S` **********************************&quot;mv $war_base_home/web-admin.war $tomcat_home/webapps/ROOT.war/opt/tomcat80/bin/startup.shecho &quot;************************服务启动完成`date +%Y-%m-%d_%H:%M:%S` **********************************&quot; 通过上述步骤我们就可以通过Jenkins进行多分支打包，并部署到服务器上了。","link":"/2074530126.html"},{"title":"基于SpringBoot2.x，Quartz的定时任务的动态修改","text":"概述:在开发中有的时候需要去手动禁止和启用定时任务,修改定时任务的cron表达式然后再让其动态生效于是有了这个例子 本例子根据 zhuyanpeng的demo 改编有兴趣的童鞋可以github搜索zhuyanpeng看他的demo.本人将其中Springboot1.x升级为2.x 删除原有的SpringUtil.java 由Spring管理TaskUtils.java 另,多谢@zhuyanpeng 提供思路.代码稍后放出. 如有启发,请点star 相关技术本次用到的技术主要有 springboot2.x Jpa Quartz H2 Thymeleaf 具体流程1) 修改 Quartz 注入方式为Spring的 防止在执行Job的时候自动注入为Null,因为 在Quartz框架中，Job 是通过反射出来的实例，不受Spring的管理。具体方式为重写SpringBeanJobFactory类中的createJobInstance方法，将创建的Job实例添加到applicationContext中，交给Spring管理。具体代码详见 HachiQuartzJobFactory.java [] [HachiQuartzJobFactory.java]12345678910111213141516171819202122232425262728293031import org.quartz.spi.TriggerFiredBundle;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.config.AutowireCapableBeanFactory;import org.springframework.scheduling.quartz.AdaptableJobFactory;/** * @BelongsProject: spring-boot-dynamic-quartz * @BelongsPackage: com.hachismart.config * @Author: smallodd * @CreateTime: 2019-04-15 16:48 * @Description: 修改QuartzJob 的注入方式为spring的 */public class HachiQuartzJobFactory extends AdaptableJobFactory { /** * 自动注入所需工厂类 */ @Autowired private AutowireCapableBeanFactory capableBeanFactory; @Override protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception { //调用父类的方法 Object jobInstance = super.createJobInstance(bundle); //进行注入,这属于Spring的技术,不清楚的可以查看Spring的API. capableBeanFactory.autowireBean(jobInstance); return jobInstance; }} 2) 手动创建一个调度器工厂对象SchedulerFactoryBean，设置一些自己业务所需的属性重点是设置JobFactory为第一步自定义的HachiQuartzJobFactory.java代码详见QuartzConfiguration.java [] [QuartzConfiguration.java]123456789101112131415161718192021222324252627282930313233import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.quartz.SchedulerFactoryBean;/** * @BelongsProject: spring-boot-dynamic-quartz * @BelongsPackage: com.hachismart.config * @Author: smallodd * @CreateTime: 2019-04-15 16:52 * @Description: Quartz配置类 */@Configurationpublic class QuartzConfiguration { @Bean public SchedulerFactoryBean schedulerFactoryBean() { SchedulerFactoryBean factoryBean = new SchedulerFactoryBean(); //使用自定义的quartzJob 工厂类 防止不能注入的问题 factoryBean.setJobFactory(hachiQuartzJobFactory()); /*用于Quartz集群,启动时更新已存在的Job*/ factoryBean.setOverwriteExistingJobs(true); /*定时任务开始启动后延迟5秒开始*/ factoryBean.setStartupDelay(5); return factoryBean; } @Bean public HachiQuartzJobFactory hachiQuartzJobFactory() { return new HachiQuartzJobFactory(); }} 3) 根据schedulerFactoryBean获取到Scheduler(任务调度器) 4) 获取触发器 判断触发器是否存在（如果存在说明之前运行过但是在当前被禁用了，如果不存在说明一次都没运行过） 存在则取出出发器 重启任务 否则 新建触发器 放到任务调度器中,代码详见QuartzTableService.java [] [QuartzTableService.java]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137import com.hachismart.enums.ConfigEnum;import com.hachismart.jpa.bean.QuartzConfig;import com.hachismart.jpa.mapper.QuartzConfigMapper;import com.hachismart.config.HachiQuartzJobConfig;import org.quartz.*;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.quartz.SchedulerFactoryBean;import org.springframework.stereotype.Service;import java.util.List;/** * @BelongsProject: spring-boot-dynamic-quartz * @BelongsPackage: com.hachismart.service * @Author: smallodd * @CreateTime: 2019-04-15 17:20 * @Description: 动态加载Scheduler service */@Servicepublic class QuartzTableService { @Autowired private SchedulerFactoryBean schedulerFactoryBean; @Autowired private QuartzConfigMapper quartzConfigMapper; public void update(Long id, String status) throws Exception { //判断是否有此ID的数据 QuartzConfig config = quartzConfigMapper.getOne(id); if (config == null) { new RuntimeException(\"未找到此定时任务\"); } if (\"1\".equals(status)) { // stop 禁用 config.setStatus(ConfigEnum.STATUS_STOP.getCode()); deleteJob(config); } else { //start 启用 config.setStatus(ConfigEnum.STATUS_START.getCode()); addJob(config); } quartzConfigMapper.setStatusById(config.getStatus(), config.getId()); } /** * 启动所有的任务 * * @return: void */ public void startJobs() { List&lt;QuartzConfig&gt; configList = quartzConfigMapper.findAll(); for (QuartzConfig config : configList) { if (ConfigEnum.STATUS_START.getCode().equals(config.getStatus())) { try { addJob(config); } catch (SchedulerException e) { e.printStackTrace(); } } } } /** * 修改cron表达式 * * @param id * @param cronSchedule */ public void updateCron(Long id, String cronSchedule) { int i = quartzConfigMapper.setScheduleById(cronSchedule, id); if (i &lt;= 0) { throw new RuntimeException(\"500!\"); } } /** * 增加任务 * */ private void addJob(QuartzConfig config) throws SchedulerException { //得到调度器 Scheduler scheduler = schedulerFactoryBean.getScheduler(); JobKey jobKey = this.getJobKey(config); //获得触发器 TriggerKey triggerKey = TriggerKey.triggerKey(config.getName(), config.getGroup()); CronTrigger trigger = (CronTrigger) scheduler.getTrigger(triggerKey); //判断触发器是否存在（如果存在说明之前运行过但是在当前被禁用了，如果不存在说明一次都没运行过） if (trigger == null) { //新建一个工作任务 指定任务类型为串接进行的 JobDetail jobDetail = JobBuilder.newJob(HachiQuartzJobConfig.class).withIdentity(jobKey).build(); //将工作添加到工作任务当中去 jobDetail.getJobDataMap().put(HachiQuartzJobConfig.SCHEDULEJOBKEY, config); //将cron表达式进行转换 CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(config.getCron()); //创建触发器并将cron表达式对象给塞入 trigger = TriggerBuilder.newTrigger().withIdentity(triggerKey).withSchedule(cronScheduleBuilder).build(); //在调度器中将触发器和任务进行组合 scheduler.scheduleJob(jobDetail, trigger); } else { CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(config.getCron()); //按照新的规则进行 trigger = trigger.getTriggerBuilder().withIdentity(triggerKey).withSchedule(cronScheduleBuilder).build(); //重启 scheduler.rescheduleJob(triggerKey, trigger); } } /** * 删除任务 * */ private void deleteJob(QuartzConfig config) throws SchedulerException { //得到调度器 Scheduler scheduler = schedulerFactoryBean.getScheduler(); //找到key值 JobKey jobKey = this.getJobKey(config); //从触发器找到此任务然后进行删除 scheduler.deleteJob(jobKey); } /** * 根据name和group得到任务的key * */ private JobKey getJobKey(QuartzConfig config) { return getJobKey(config.getName(), config.getGroup()); } private JobKey getJobKey(String name, String group) { return JobKey.jobKey(name, group); }} 5) 创建一个任务类需要继承Job，实现方法execute,根据反射执行对应的job,代码详见HachiQuartzJobConfig.java [] [HachiQuartzJobConfig.java]123456789101112131415161718192021222324252627282930313233343536import com.hachismart.jpa.bean.QuartzConfig;import com.hachismart.utils.TaskUtils;import org.quartz.DisallowConcurrentExecution;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * @BelongsProject: spring-boot-dynamic-quartz * @BelongsPackage: com.hachismart.config * @Author: smallodd * @CreateTime: 2019-04-15 16:52 * @Description: 定时问题调用方法 * @DisallowConcurrentExecution 注解表示禁止并发执行多个相同定义的JobDetail, 但是不是禁止执行相同的任务 */@DisallowConcurrentExecution@Component(\"hachiQuartzJobConfig\")public class HachiQuartzJobConfig implements Job { public static final String SCHEDULEJOBKEY = \"scheduleJob\"; @Autowired private TaskUtils taskUtils; //execute会根据cron的规则进行执行 @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { QuartzConfig config = (QuartzConfig) jobExecutionContext.getMergedJobDataMap().get(SCHEDULEJOBKEY); taskUtils.invokMethod(config); }} 经过如上描述动态修改cron表达式的核心以及写好了,外围的crud详见github,该项目的github地址为: https://github.com/smallodd/spring-boot-dynamic-quartz 如有帮助,烦请点击start","link":"/2628687485.html"},{"title":"一起学Java之合理的配置线程池以及线程池的监控","text":"前言使用线程池的时候，我们最迷惑的就是如何去配置线程池，一旦线程池配置不合理很可能会导致系统异常。出了异常我们就需要监控异常。下面我们一起来总结一下如何合理的配置以及如何监控。 线程池的设置想要合理的配置线程池，就要先了解任务的特征，简单来讲，我们在判定任务的特征的时候可以从以下几个角度来分析 任务的类型 CUP使用密集：这种类型的任务不易配置过多的线程，因为多了有可能会导致CPU资源耗尽，即配置尽可能小的线程，例如配置CUP个数+1个线程的 线程池。 IO密集：由于IO执行需要时间，所以线程不一定是一直在执行任务，所以配置尽可能多的线程，例如配置CPU个数的2倍个线程的线程池 IO、CPU混合密集：这种类型的，看看是否可以拆分，如果可以拆分就将任务拆分为一个IO密集任务和CUP密集任务，但是如果拆分后的两个任务执行时间相差很大就没必要拆分了。 任务是否有优先级：这种类型的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。但是有一点要注意，如果设置了优先级，那么优先级低的可能永远不会执行。 任务大致的执行时间（长、适中、短）：这种类型的任务，不同时间长的任务交给不同规模线程池处理，当然最懒的办法就是交给优先级队列处理，时间短的优先执行 任务是否依赖其他资源，例如第三方接口：如果依赖其他资源，表示要其他资源给的响应，等待时间越长，CUP空闲时间就越长，所以线程数要大些才能更好的利用CPU资源 阻塞队列的选择强烈建议使用有界的队列，使用无界队列如果队列中任务堆积导致内存挂掉，那么会导致整个服务不可用，使用有界的队列可以通过设定好的策略来判断线程执行状况，如果其中一个线程耗时太久，队列不会堆积，系统正常运行，只需要解决到这个耗时太久的问题即可。不会影响服务的运行。 线程池的监控线程池提供了以下属性来帮我们监控 taskCount:这个参数表示线程池需要执行的任务数量。 completedTaskCount:这个参数表示线程池在运行过程中已完成的任务数量,小于或等于｀taskCount｀。 largestPoolSize:这个参数表示线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小,则表示线程池曾经满过。 getPoolSize:线程池的线程数量。如果线程池不销毁的话，这个数量只曾不减。 getActiveCount:获取活动的线程数。 当然线程池也提供的方法让我们重写，他们分别是beforeExecute、afterExecute和terminated方法,可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如,监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。 以上就是我们要了解的。希望读完这篇文章，可以让大家合理的准确是使用线程池。","link":"/1781080007.html"},{"title":"一起学Java之线程池","text":"前言在开发中我们会使用多线程来提高效率,Java中提供了线程池，线程池是运用场景最多的并发框架，可以这么说，几乎所有需要异步或者并发执行任务的程序都可以使用线程池。合理的使用线程池可以降低资源消耗，提高响应速度，更加方便的管理线程。 线程池主要的处理流程要想了解一件事，那么我们必须先了解这件事的流程，所以我们要了解一下线程池的主要处理流程。 任务提交以后，线程池判断核心线程是否都在执行任务，如果没有，就新建一个线程来执行这个任务，如果有那么进入第二步。 线程池判断工作队列中是否已满，没有，就把这个队列存储到工作队列中去，如果满了，就执行第三步。 线程池判断线程池的线程是否都处于工作状态，如果没有，就创建一个线程来执行任务，如果已经满了，就按照策略处理无法执行的任务。 主要的处理流程见下图 线程池的使用线程池的创建下面我们来看下线程池的使用，在Java中我们可以通过ThreadPoolExecutor来创建一个线程池，初始化线程池的时候要有几个参数（基于jdk1.8），我们一起来看下 corePoolSize： 这个参数表示线程池的基本大小，根据线程池的处理流程我们可以知道，当提交一个任务到线程池中的时候，线程池会创建一个线程来执行任务，这里需要注意一点，当线程池的基本大小没满的时候，不管线程池有没有空闲，他都会创建一个线程来执行，直到线程池的基本大小满了，就不在创建了，有的同学就会问了，能不能不在提交任务的时候创建呢，当然是可以的，线程池提供了一个prestartAllCoreThreads()的方法，调用这个方法以后，线程池会提前创建并启动所有基本线程。 maximumPoolSize： 这个参数表示线程池的最大数量，简单的来说就是线程池允许创建的最大的线程数量。如果工作队列满了，线程池就会新建一个线程来执行任务，但是有一点，如果任务队列的大小是无限大的时候，这个最大值就没有用了，因为不管你有多少任务，他都会进入到任务队列中去。 keepAliveTime： 线程的保活时间，就是在线程池中有一个工作线程空闲了，这个线程可以存活多长时间，如果每个任务的执行时间比较短的话，我们可以加大线程的保活时间，这样线程的利用率就提高了 unit： 线程保活的单位，详见TimeUnit，可以是天、小时、分钟、秒、毫秒、微妙、纳秒 workQueue： 工作队列，作用是用来保存等待执行任务的阻塞队列，阻塞队列有多种下面我们来一一看下 ArrayBlockingQueue： 看名字是不是很熟悉，像不像ArrayList，通过名字我们可以看出，肯定是基于数据结构的，所以呢ArrayBlockingQueue是一个基于数据的，有界的（可以设置队列大小）阻塞队列，这个队列按照先进先出的原则对队列中的任务进行排序 LinkedBlockingQueue： 同理，这个一看就知道是基于链表的阻塞队列，这个队列也是按照先进先出原则进行排序，由于使用的是链表，插入删除效率高，所以吞吐量是要高于ArrayBlockingQueue的 SynchronousQueue：这个是一个不存储元素的阻塞队列，看名字就知道，同步，这表示每一个插入操作都必须等到另一个线程的移除操作，不然插入操作就会一直阻塞 PriorityBlockingQueue: 一个支持优先级的无界阻塞队列，直到系统资源耗尽，使用的较少。 threadFactory：用来设置创建线程的工厂，一般的都使用guava提供的ThreadFactoryBuilder来创建，例如通过ThreadFactoryBuilder来给线程设置名字，方便后期查问题，代码示例： 123456789101112131415161718192021public static void main(String[] args) { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 3, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;(2),new ThreadFactoryBuilder().setNameFormat(&quot;hachi-test-%d&quot;).build()); threadPoolExecutttr.prestartAllCoreThreads(); for (int i = 0; i &lt;3 ; i++ { threadPoolExecutor.execute(new Runnable() { @Override public void run() { System.out.println(&quot;线程&quot;+ Thread.currentThread().getName()+&quot;执行&quot;); try { TimeUnit.SECONDS.sleep(1L); } catch (InterruptedException e) { e.printStackTrace(); } } }); }} 输出示例： 123线程hachi-test-2执行线程hachi-test-0执行线程hachi-test-1执行 handler: 表示当队列已经饱和的时候使用的策略，类型为：RejectedExecutionHandler即如果队列和线程池都满了就需要一种策略来处理新加入的任务。jdk提供了4钟策略来处理这种情况 AbortPolicy：直接抛出异常，这也是ThreadPoolExecutor默认的策略 CallerRunsPolicy: 只要线程池未关闭，就用调用者所在的线程来执行任务，这样做的好处是可以不用丢弃任务，坏处是可能导致调用者线程的性能急剧下降 DiscardOldestPolicy: 这个就比较流氓了，当任务进来的时候，直接丢去队列里面最近的一个任务，并执行当前任务。 DiscardPolicy:不处理,丢弃掉。 通过查看jdk 源码来看上述四种策略都是在ThreadPoolExecutor中的静态内部类，详细代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 /** * A handler for rejected tasks that runs the rejected task * directly in the calling thread of the {@code execute} method, * unless the executor has been shut down, in which case the task * is discarded. */public static class CallerRunsPolicy implements RejectedExecutionHandler { /** * Creates a {@code CallerRunsPolicy}. */ public CallerRunsPolicy() { } /** * Executes task r in the caller&apos;s thread, unless the executor * has been shut down, in which case the task is discarded. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { r.run(); } }}/** * A handler for rejected tasks that throws a * {@code RejectedExecutionException}. */public static class AbortPolicy implements RejectedExecutionHandler { /** * Creates an {@code AbortPolicy}. */ public AbortPolicy() { } /** * Always throws RejectedExecutionException. * * @param r the runable task requested to be executed * @param e the execuutor attempting to execute this task * @throws RejectedExecutionException always */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); }}/** * A handler for rejected tasks that silently discards the * rejected task. */public static class DiscardPolicy implements RejectedExecutionHandler { /** * Creates a {@code DiscardPolicy}. */ public DiscardPolicy() { } /** * Does nothing, which has the effect of discarding task r. * * @param r the runnable task requested toe executed * @param e the executor attempting to execuuute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { }}/** * A handler for rejected tasks that discards the oldest unhandled * request and then retries {@code execute}, unless the executor * is shut down, in which case the task is discarded. */public static class DiscardOldestPolicy implements RejectedExecutionHandler { /** * Creates a {@code DiscardOldestPolicy} for the given executor. */ public DiscardOldestPolicy() { } /** * Obtains and ignores the next task that the executor * would otherwise execute, if one is immediately available, * and then retries execution of task r, unless the executor * is shut down, in which case task r is instead discarded. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { e.getQueue().poll(); e.execute(r); } }} 所以我们也可以手动实现RejectedExecutionHandler接口来自定义策略，例如记录log，或者任务重启机制等 向线程池中提交任务在ThreadPoolExecutor中提供了两种方法想线程池中提交任务，分别是execute()和submit()。下面我们来了解一下这个方法 execute： 通过查看jdk源码我们不难发现execute方法的入参是一个Runnable()对象，但是是没有回参的所以我们无法判断任务是否被线程池执行成功。示例代码： 123456789101112threadPoolExecutor.execute(new Runnable() { @Override public void run() { System.out.println(&quot;线程&quot;+ Thread.currentThread().getName()+&quot;执行&quot;); try { TimeUnit.SECONDS.sleep(1L); } catch (InterruptedException e) { e.printStackTrace(); } } }); submit: 通过查看jdk源码我们可以发现 submit方法是来源于接口ExecutorService，AbstractExecutorService实现了ExecutorService，ThreadPoolExecutor继承了AbstractExecutorService。 这个方法是可以返回一个Future类型，通过这个回参的get()方法可以获取返回值。 get()方法会阻塞当前线程直到任务完成 get(long timeout,TimeUnit unit)会根据传入的时间来阻塞一段时间然后立即返回，这个时候任务很可能未完成 下面我们看下submit方法的代码 1234567891011121314151617181920212223242526272829303132/** * @throws RejectedExecutionException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */public Future&lt;?&gt; submit(Runnable task) { if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;}/** * @throws RejectedExecutionException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) { if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); execute(ftask); return ftask;}/** * @throws RejectedExecutionException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) { if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask;} 可以看到有三个submit方法。但是只有实现了Callable接口才能有返回值， Runnable是没有的，即submit(Runnable task)返回的值调用get方法后会返回一个null。而submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值，如果执行失败就会获取到异常，如果执行成功就会拿到之前定义好的值下面我们介绍一下submit(Callable&lt;T&gt; task) 示例代码详见： 123456789101112131415161718public static void main(String[] args) throws ExecutionException, InterruptedException { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 3, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;(2),new ThreadFactoryBuilder().setNameFormat(&quot;hachi-test-%d&quot;).build()); threadPoolExecutor.prestartAllCoreThreads(); for (int i = 0; i &lt;3 ; i++) { Callable&lt;HttpClientResultBean&gt; callable = new Callable&lt;HttpClientResultBean&gt;() { public HttpClientResultBean call() throws Exception { System.out.println(&quot;线程&quot;+ Thread.currentThread().getName()+&quot;执行&quot;); return new HttpClientResultBean(); } }; Future&lt;HttpClientResultBean&gt; future= threadPoolExecutor.submit(callable); System.out.println(JsonUtils.obj2Json(future.get())); }} 关闭线程池通过上述操作我们创建了线程池，并且向线程池中新增了任务，那么我们如何关闭线程池呢？jdk提供了shutdown和shutdownNow两个方法来关闭线程池。原理是遍历线程池中的工作线程,然后逐个调用线程的interrupt方法来中断线程,所以无法响应中断的任务可能永远无法终止。那么他们有啥区别呢？ shutdown： 仅仅是将线程池的状态设置成SHUTDOWN状态，然后中断没有正在执行的任务线程 shutdownNow：首先将线程池的状态设置成｀STOP｀,然后尝试停止所有的正在执行或暂停任务的线程,并返回等待执行任务的列表 注意： 只要调用了两个方法的任意一个,isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功,这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池,应该由提交到线程池的任务特性决定,通常调用shutdown方法来关闭线程池,如果任务不一定要执行完,则可以调用shutdownNow方法。","link":"/1392887984.html"},{"title":"熊猫翻滚之deepin的使用","text":"前言本文假定你知道什么是 熊猫翻滚 ，主要描述的是 熊猫翻滚 在 ddepin 上的使用，因为官网上的教程是没有讲 deepin 上是咋用的，导致 deepin 的用户花钱不能使用。所以本文主要解决这个问题。 所需工具 Clash Clash是一款开源免费的代理软件 下载地址：https://github.com/Dreamacro/clash/releases 2. 熊猫翻滚上维护的Clash配置文件 一个deepin系统 一个浏览器 开始配置 运行下载好的Clash 初次运行会在 ～/.config/clash/ 文件夹下生成俩文件 config.yaml 、Country.mmdb config.yaml存放着服务器及规则等信息 Country.mmdb 很显然是个数据库文件 下载熊猫翻滚维护的配置文件，并打开把内容拷贝到～/.config/clash/config.yaml文件中 重启Clash。 如果是用终端打开的，那么只需要Ctrl+C即可 如果是直接运行就需要查询到Clash运行的pid 然后kill掉它 这个时候就需要打开http://clash.razord.top/这个网址可以看到配置好的路线 在deepin中设置代理。 在 设置&gt;网络&gt;系统代理&gt;手动 中按照yml配置文件中设置的端口进行配置。至此便可通过Clash上网。 基本配置就是这样了，那么每次电脑重启都要手动启动Clash岂不是很麻烦，所以我们需要开机自动启动。 如何配置开机自启Clash要解决这个问题我们需要知道在deepin中图标文件的咋写，图标文件存放的位置 图标文件的位置位于 /usr/share/applications/ 图标文件咋写(详情见代码块) 图标文件是以desktop为拓展名的文件 123456789[Desktop Entry]Categories=Network;Comment=clashExec=/opt/clash/clash-linux-amd64 %UIcon=/opt/clash/clash.pngName=clashTerminal=falseType=ApplicationX-Deepin-Vendor=user-custom","link":"/38999229.html"},{"title":"一起学Java之wait、notify 和 notifyAll","text":"前言本文主要描述了wait、notify 和 notifyAll 的作用，超级无敌枯燥，需要耐心看完，并多读几遍。 什么是 wait、notify 和 notifyAllwait 暂停某个线程，实现线程等待，前提是必须先获得锁(因为wait主要做的事情就是把锁释放了，并等待唤醒) 同一个对象的wait方法可以被不同线程执行，所以一个对象可能有多个等待线程。 wait是原子操作的方法,当wait执行时，释放对象内部锁，进行等待，当符合条件的时候，会重新获得对象的内部锁，再继续判断条件往下执行，如果不符合条件就会重新进行wait.直到条件成立，执行完目标动作这个方法才算完成. notify 和 notifyAll说明 notify/notifyAll所在的线程叫做通知线程，主要作用是唤醒线程 执行notify之后，通知唤醒该对象相关的一个线程（notifyAll线程唤醒相关的所有线程） 待线程收到通知，并申请获得对象的锁之后，该等待线程会从该对象的wait set等待集中移除 notify 和 notifyAll 都是唤醒线程，唤醒之后都是去竞争一个对象的内部锁，两者有什么区别呢，这就要从Java的锁模型开始说起了。synchronized大家都很熟悉了，JVM会为使用synchronized的对象维护俩集合锁池(洋文： Entry Set)和等待池(洋文： Wait Set) 详解 当对象已经有一个线程(姑且叫线程A)获得了对象锁，另一个线程(你就叫线程B吧)也想获得这个对象的对象锁时，线程B发现这个对象的对象锁被线程A这个傻屌获取了，线程B气的没办法只能去锁池，此时的线程B处于BLOCKED状态。等过了一会儿，线程A突然执行了wait，释放了对象锁，这个时候线程A就会进入等待池，并且这时候的线程A处于WAITING状态。这时候JVM大佬通知锁池，有一个锁释放了，然后线程B一看正好是自己要获得的锁那么这个时候线程B就会由原来的BLOCKED转变为RUNNABLE。要知道，线程B想要获得对象锁有俩条件，一个是对象锁被释放，一个是自己处于RUNNABLE状态。都符合。那就可以去竞争这个对象锁了。优先级高的线程竞争到对象锁的概率大。如果线程B没有竞争到锁，那就继续在锁池中等待锁的释放。 上述情况主要讲的是锁池里面的线程变化情况。那么等待池里面的状态如何变化呢。实际上是差不多的，当线程A调用wait的时候线程A进入等待，池线程的状态就从WAITING，线程B开始，当线程B调用notify 或 notifyAll 的时候线程A就可以重新将状态变为RUNNABLE。如果遇到资源竞争，那么刚刚从等待池里面出来的线程就会到锁池里面。 了解了上面的骚操作以后，我们来谈谈notify 和 notifyAll的区别，有的童鞋会说很简单啊，notify是唤醒一个线程，notifyAll是唤醒所有线程。都是唤醒都是拿到一个锁。其实不然，里面还是有许多说道的。例如有一个场景俩生产者、俩消费者、一个资源。消费者线程1去拿资源发现为null那么他就会 wait 进入等待池，消费者2 去拿资源，也发现是null，他也进入等待池，这时候生产者1，生产者2去竞争锁，不巧生产者1获得了锁，去生产了资源，生产者2继续在锁池里面等待。生产者1执行完了这次任务后就挂了。生产者1假设使用了notify唤醒一个线程，这时候唤醒了消费者1，但是不要忘记了生产者2也要用到这把锁，不巧，生产者2竞争到了这把锁，当他满怀期待的去生产资源的时候，ok资源满了。这下，生产者2只能wait了，进入了等待池。锁池里面的消费者1、消费者2会去竞争这把锁，假设消费者1拿到了，去消费了，并调用notify。这时候如果唤醒生产者2，那么没毛病，继续正常走，但是™如果唤醒了消费者2，消费者2一看资源为空，继续wait。得由于没有线程notify，俩二货就会一直在等待，形成线程死锁。但是，如果使用notifyAll就可以避免这种麻烦。因为不管什么时候，所有的线程都会从等待池到锁池里面。都有机会去竞争锁. 总结一下，大致意思就是说 建议使用notifyAll 因为notify有一定几率会导致死锁。不管相对而言notify比notifyAll更加省资源。 5.为什么 wait，notify 和 notifyAll 是在 Object 类中定义的而不是在 Thread 类中定义呢？原因主要有以下几点 通过上述的描述我们知道 wait、notify 和 notifyAll 是两个线程之间的通信机制，因为要确保每个对象都有这个机制，所以声明到Object中去 是对象上锁，然后线程等待，而不是线程之间相互知道哪个线程上的锁，然后去请求锁释放","link":"/1747159659.html"},{"title":"浅谈app中数据收集","text":"前言数据,一个在代码生涯中必不可少的成员.在一个app运营的时候一定要监控和收集大量的数据作为分析的资本.可以说数据即一切.那么哪些数据是需要我们关心并且去收集 统计 近而分析他呢. 下面我们一起来看下. 数据来源对于一个app来说,数据来源大致分为两种 app本地数据 app本地数据,例如用户操作app时在app上的操作数据 app运行时产生的数据(包括异常数据)等 app线上数据 app在运行时免不了与服务端进行交互,交互就要产生数据0例如app请求服务端是服务端进行了怎样的流程 产生了怎样的数据,达到了怎样的结果等. app的下载数据 本文主要针对app本地数据进行阐述 app本地数据的分类 页面曝光 即当前屏幕页面上有哪些模块(内容) 页面信息 即用户进入了那一页 埋点行为 即用户点击了哪些 app激活数据 即有哪些手机安装了app 什么时候上报app本地数据app端在什么时候上报数据呢?用户在使用app过程中肯定会出现网络不好的情况,那么我们如何保证在没有网络的情况下准确上报数据呢?很简单,持久化到本地呗,那么我们什么时候开始上报这些数据呢?通常来讲,用户使用app的时候经常会做以下操作: 用户打开app 用户在app界面按下home键 用户在切换应用 既然多数app都会进行这三项操作,那么我们可以通过上述时机来上报app本地数据,这样做确保了数据的准确性 收集哪些数据既然要收集数据,那肯定要确定收集哪些.上面我们有提到了app本地数据的分类那我们就按照分类来一一说明 页面曝光 收集的信息 说明 上报方式 用户id 用来确定是哪个用户进行了操作 曝光屏数 当前页在第几屏幕曝光出数据的 曝光内容id 曝光内容名称 曝光时间 手机唯一标识 用来区分手机 app版本 app平台 页面id 页面名称 手机厂商 手机型号 系统id(名称) 网络类型 打开页面时候的网络类型(WiFi 移动4g 联通4g 等) 网络运行商 移动 电信 联通 等 ip 打开页面时的外网ip 上报时间 注意和曝光时间的区别,曝光时间不一定是上报时间 页面信息 收集的信息 说明 上报方式 用户id 用来确定是哪个用户进行了操作 页面url 手机唯一标识 打开页面时间 页面id 页面类型 上一页页面id 上一页页面类型 app版本 app平台 页面id 页面名称 手机厂商 手机型号 系统id(名称) 网络类型 打开页面时候的网络类型(WiFi 移动4g 联通4g 等) 网络运行商 移动 电信 联通 等 ip 打开页面时的外网ip 上报时间 埋点行为 收集的信息 说明 上报方式 用户id 用来确定是哪个用户进行了操作 手机唯一标识 行为名称 也就是点击了哪个按钮之类的 行为编码 行为触发时间 行为结束时间 页面id 页面类型 app版本 app平台 页面id 页面名称 手机厂商 手机型号 系统id(名称) 网络类型 打开页面时候的网络类型(WiFi 移动4g 联通4g 等) 网络运行商 移动 电信 联通 等 ip 打开页面时的外网ip 上报时间 app激活数据 收集的信息 说明 上报方式 激活时间 手机唯一标识 手机厂商 手机型号 系统id(名称) 网络类型 打开页面时候的网络类型(WiFi 移动4g 联通4g 等) 网络运行商 移动 电信 联通 等 ip 打开页面时的外网ip 上报时间 通过上述,我们应该对什么时候app数据收集 以及采集哪些数据有了一定的认识.希望本文可以帮助到大家.","link":"/3860430980.html"},{"title":"一起学MySQL之MySQL简介","text":"前言本文主要讲的是MySQL的一些知识，那么，MySQL是什么呢？下面我们来了解一下 什么是MySQLMySQL是一个关系型数据库，是Oracle公司旗下的，MySQL是世界上最流行的关系数据库之一，在开发中经常使用，别问为什么 因为免费 MySQL中的数据类型整数类型整数类型，主要包括的数据类型如下表，任何的整数类型都可以加上UNSIGNED属性，这个属性是干什么的呢，这个属性表示无符号，也就是说不管正整数负整数进入数据库的都是正整数。正数类型是可以定义长度的例如bigint(20)表示长度为20的整数类型。这里还要介绍一个属性ZEROFILL，这个属性表示补零，经常和UNSIGNED配合使用，例如int(3),如果使用了UNSIGNED ZEROFILL属性，插入数据为7的话，数据库存的就是007 类型名称 说明 tinyint 很小的整数(8位二进制，一个字节) smallint 小的整数(16位二进制，两个字节) mediumint 中等大小的整数(24位二进制，三个字节) int 普通大小的整数(32位二进制，四个字节) bigint 很大的整数(64位二进制，八个字节) 小数类型小数类型包括的数据类型如下表，decimal可以存储比bigint还要大的整数，能存储精确的小数，在不指定精度的情况下，默认为(10,0)，float、double都是有取值范围的，支持使用标准的浮点进行近似计算,在不指定精度时，默认会按照实际的精度来显示。根据经验，精度高的效率低，效率高的精度低。 类型名称 说明 float 单精度浮点数 double 双精度浮点数 decimal 压缩严格的定点数 日期类型日期类型，如果追求效率，不在乎2038年的时间范围的话，那就使用timestamp，因为空间效率直接把datetime甩了十几条街，如果需要存储微妙，那建议用bigint存储，如果不考虑效率，那最好直接datetime，简单粗暴易维护，不必担心2038年的问题，timestamp有一个特性就是自动更新。 类型名称 说明 year yyyy(1901~2155) time HH:mm:ss -838:59:59 ~ 838:59:59 datetime yyyy-MM-DD HH:mm:ss 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 timestamp yyyy-MM-DD HH:mm:ss 1970-01-01 00:00:00 ～ 2038-01-19 3:14:07 ｜ 文本二进制类型数据类型如下，对于字符串类型，能用char的不要用varchar，varchar中会存储字符串的长度。当列长度小于255字节时，使用1字节，当大于255的时候就需要两个字节表示了，当char或者varchar存储的内容超出设置的长度时，内容会被截断。cha是根据定义的字符串的长度分配内存空间的。 类型名称 说明 char 可定义长度(0~255之间) varchar 可定义长度(0~65535之间) tinyblob 允许长度0~255字节 blog 允许长度0~65535字节 mediumblog 允许长度0~167772150字节 longblob 允许长度0~4294967295字节 tinytext 允许长度0~255字节 text 允许长度0~65535字节 mediumtext 允许长度0~167772150字节 longtext 允许长度0~4294967295字节 varbinary 可定义长度允许0~定义长度之间的字节 MySQL的索引 索引(Index)是帮助MySQL高效获取数据的数据结构，大概就是可以帮助快速查找的一种数据结构。那么为什么要使用索引呢，很明显就是为了快，为了提高检索 效率，降低服务器的io成本，降低了CPU的消耗。缺点是每次对表进行更新操作、插入操作、删除操作都要保存一下索引，数据量大索引也大。 索引的类型 类型名称 说明 主键索引 不允许重复，不允许为null 普通索引 无唯一性限制，基本索引，允许为null 唯一索引 不允许为null，数据列不允许重复 全文索引 一般搜索引擎使用的技术 索引的算法 btree btree是mysql默认的索引算法，他可以被用在比较运算符上(例如大于、小于、大于等于、between…等等)也可以用在like，但是like有限制，只作用于匹配不以通配符开头的数据类似与这样的写法 like ‘small%’，这样的写法可以使用索引，但是 like ‘%odd’这种就不会使用索引了 hash算法 hash算法只能作用于比较运算符，因为主要是基于Hash算法所以检索效率要比btree索引要高 创建索引的原则 查询较为频繁的字段适合建立索引 更新频繁的字段不适合做索引 关联字段一定建索引 索引尽量只更新不新建，例如原来有个索引a，现在要再加一个索引(a,b)，那么就更新这个索引就可以 数据类型为text、blog的列不要建立索引 区分度低的不适合建立索引，例如支付状态(待支付、支付中、已支付、已退款。至少有这几种状态区分度极低) 最左前缀匹配原则(组合索引经常用到)，MySQL会从左到右匹配，直到匹配到范围查询(&gt;、&lt;、between、like…等)就会停止使用索引，例如有一个混合索引的顺序为(a,b,c) 当sql为 a=1 and b&gt;2 and c=3 的时候 a和b的索引都会用到c的索引就不会用到了，那么怎么优化呢，就把顺序调整一下由原来的(a,b,c)改成(a,c,b)，这样三个索引就都可以用到了 非空字段才能加索引，因为含空值的列在MySQL中很难优化 索引字段越小越好 MySQL的存储引擎 Innodb: 支持ACID的事物支持，提供表级锁、行级锁，不支持全文索引，支持Hash索引，是我们经常用的存储引擎 MyIASM: 不支持事物，不支持行级锁，但是存储空间少，查询效率高，不支持Hash索引，支持全文索引 MEMORY: 数据存储在内存里面，数据处理快，但是安全性低 事物的ACID 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的； 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 MySQL的explain 作用:查看sql语句的执行计划，包含了这条sql查询了哪些表，查询这些表的顺序是什么，使用了哪种方式查询，扫描了多少行等 执行计划字段的含义 字段名称 说明 id 表示sql的执行顺序 select_type 查询类型 table 查询的表名 type 访问类型 possible_keys 可能使用的索引 key 实际使用的索引 key_length 索引长度 ref 上述表的链接匹配条件 rows 返回结果集的数目 extra 一些说明 3.字段详解 id id相同的执行顺序从上到下 id不同的id越大优先级越高 id为null的时候是表示这是一个结果集，不需要查询 select_type SIMPLE: 简单查询，不包含子查询或者连接查询 PRIMARY: 子查询的最外面一层的查询就是PRIMARY SUBQUERY: where字句中包含的子查询 DERIVED: from 中包含的查询 UNION: union后查询的语句 UNION RESULT：UNION中获取结果集 type ALL: 全表扫描 index: 遍历索引查找 range: 在索引的范围内查询 index_subquery: 在子查询中使用ref unique_subquery: 在子查询中使用 eq_ref ref_or_null: 对ｎｕｌｌ进行索引优化的ref fulltext: 使用全文索引 ref: 使用非唯一索引查找数据 eq_ref: 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联 possible_keys 查询字段中如果有索引就会被列出来，如果为null就看看sql是否需要优化 key 实际索引，没有用到就是null key_length 索引的长度，这个没别的意思 ref 该表的连接匹配条件，就是那些列或者常量被用于查找索引列上的值 rows 扫描行数，并不一定准确 extra Using index 使用覆盖索引 Using where 使用where来过滤 Using filesort 使用文件排序，使用非索引的列进行排序的时候出现，超级无敌消耗性能，一旦见到就要优化 Using temporary 使用临时表，尽量做优化 ４. sql目标 至少要达到range级别,要求达到ref级别，最好是consts级别 consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 ref 指的是使用普通的索引 range 对索引进行范围检索","link":"/2769782386.html"},{"title":"玩转spring之Factory（工厂模式）","text":"Factory模式1.工厂模式也是我们编程中使用的最广泛的设计模式之一，工厂模式主要用来实例化对象，代替new操作。 工厂模式的简单实现1.举这样一个例子，假如有一个大老板，需要买一辆车，但是他并不知道现在市面上有些什么车，他来到汽车销售中心，对招待说，我有这么些钱，我要买车，你看这办吧，这个时候招待就会根据老板具体有多少钱而向他销售不同价位款式的汽车。下面我们用代码来模拟 2.首先，定义一个接口Car 3.创建多个Car接口的实现类 4.实现CarFactory 5.main方法测试 6.在该工厂模式的简单实现中，可以发现工厂模式使用时的一些特点 在编码时不能预见需要创建哪一种类的实例 一个类使用它的子类来创建对象 开发人员不希望将创建了哪个类的实例以及如何创建实例的信息暴露给外部程序","link":"/452468995.html"},{"title":"玩转spring之Singleton（单例模式）","text":"Singleton模式简介1.单例模式是我们编程中使用最广泛的设计模式之一，作用就是保证在应用中，一个类只有一个实例存在 2.单例模式有三个特点 该类只有一个实例 该类自行创建该实例（在该类内部创建自身的实例对象） 向整个系统公开这个实例接口 Singleton模式的简单实现1.最简单的单例实现方法，即将构造方法私有化，在类的内部创建该类的唯一实例，然后提供一个静态方法作为获取该实例的接口，犹如以下代码 2.则该Singleton类的实例可以通过如下这句代码获得 3.上面的单例实现方式会在Singleton类加载的时候立即初始化一个实例，称为饿汉式加载。但对于资源开销比较大的类，更适合的做法是将实例化推迟到第一次使用它的时候，即懒汉式加载（惰性加载），比如以下代码","link":"/44388.html"},{"title":"一起学java之Java中的反射机制简介","text":"概述Reflection,反射,在java中指的是我们可以于运行时加载,探知,使用编译期间完全未知的类,包括实例化对象,唤醒其方法,对其fields设值等 Class类1.在java中,万物皆对象,java中的类是为了描述对象,包括:类名,属性,方法等类结构,java中把类的描述也定义为类,该类比较特殊,名称是Class.每一个类在加载时,虚拟机都会根据加载的类创建对应的Class对象,放在内存的程序区,Class对象是具体类的描述,包括具体类的类名,方法,属性,构造方法等。 2.理解Class类 Class类的应用1.如何加载类 在第一次使用类时会加载类，（声明类的变量或new类的对象） 主动加载（类名.class 或 Class.forName(“类名”)） Class对象一旦加载成功，在程序运行结束之前，Class对象永远存储在程序区，直到应用程序结束 一个类只加载一次，重复加载则无效 举例： 2.如何得到一个类的Class对象 对象名.class 类名.class Class.forName(“类名”) 举例 3.如何获得一个类有哪些属性 方法名称 说明 Field[] getFields() 得到类的公共属性 Field[] getDeclaredFields() 得到声明的字段 Field getField(String ) 得到对应的字段,必须是公共的 … … 举例 4.如何获得一个类有哪些方法 常用方法 方法名称 说明 Method[] getMethods() 得到类的公共方法，包括父类的 Method[] getDeclaredMethods() 得到声明的方法，不包括父类的 Method getMethod(String，…Class ) 得到对应的方法 … … 举例 5.如何产生一个类的对象 使用newInstance()方法 举例 6.如何使用类的属性，赋值和取值 举例 7.如何使用类的方法，调用方法 Invoke()方法 举例","link":"/2909453862.html"},{"title":"一起学java之线程简介","text":"前言至今为止，我们开发的java project在同一时间只能进行一项任务，如果程序运行中遇到了耗时的任务，程序必须等待任务完成之后才能执行后面的代码。这样的单线程结构不能充分的利用计算机的硬件资源，代码运行效率不高，合理的利用多线程结构，可以并行的处理多项任务，避免了不相关任务之间的等待，充分利用硬件资源提高程序的效率 什么是线程1.程序：写好的代码，不一定运行 2.进程：运行起来的程序就叫进程 3.线程：一个进程中可能包含多端程序并发执行，每一段独立的正在执行的程序称之为线程。也就是说，一个进程由若干个线程组成，main函数启动进程，那么该线程称之为主线程。 4.通常情况下，只有子线程运行结束，主线程才会结束，主线程结束，那么进程也就结束了，特殊情况下，主线程结束，子线程随之马上结束，那么该子线程称为守护线程。 5.多个线程之间可以并发执行，也可以根据需要让一个线程等待另一个线程，或暂停一个线程。一般来说，线程的状态有就绪（new）、执行（runnable）、等待（waiting）、阻塞（blocked）、终止（terminated）等。 线程实现1.线程实现，需要创建线程对象。线程实现主要有两种方法 实现Runnable接口 举例 继承Thread类 举例 2.应用实例-多线程文件拷贝 用来拷贝的类FileCopyThread main方法测试 说明： 线程必须覆盖父类的run方法，run方法中的代码会在线程启动的时候执行的时候执行，run方法执行结束，线程也就执行结束，变为终止状态。 实例化线程会使线程处于就绪状态，但这时不会执行线程中的代码 调用线程的start方法会启动线程，将线程变为执行状态 在硬件资源允许的情况下,使用多线程并行复制要比单线程逐个复制快很多 线程等待1.使用Thread.sleep()，可以让当前线程等待一段时间 2.使用TimeUnit.SECONDS.sleep(),可以让当前线程等待一段时间,其中的SECONDS 表示的是秒,还可以是分钟,小时,天等 守护线程1.除了希望并行执行的代码会使用线程，一些不间断的监视工作也会用到线程 2.java垃圾回收线程即是一个守护线程 3.举例 实现监视磁盘空间的Thread类 main方法测试 说明 执行thread.setDaemon(true)可以将线程标记为守护线程 在所有非守护线程结束后，程序就会终止执行 一旦线程已经启动，就不能调用setDaemon()方法了 线程安全1.B/S架构软件开发模式会经常遇到多线程并行访问的问题，一段代码如果在多线程并行访问的情况下依然能够得到预期的结果，称之为线程安全，否则为非线程安全 2.非线程安全的例子 3.解决办法 加锁 加同步块 说明 一般认为，如果一段代码可能被多个线程访问，这段代码又会访问诸如堆内存中的对象，数据库中的数据，磁盘上的文件等公共资源时需要加锁，如果只需要访问栈内存中的数据，不需要加锁。","link":"/558031296.html"},{"title":"一起学java之I/O简介","text":"前言Java的核心库java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。Java中IO是以流为基础进行输入输出的，所有数据被串行化写入输出流，或者从输入流读入。 File文件操作1.Java如何描述文件系统:File类 2.File类中常用的方法: 3.方法举例 IO流结构1.IO流的用途,进行文件等的读写操作 2.IO流的概念:流可以理解为连续的数据 3.IO流的分类: 输入流和输出流 文件操作流和内存操作流等 字节操作流和字符操作流等 4.结构图 5.一般来说,IO流的后缀有InputStream,OutputStream,Reader,Writer四种,分别代表字节输入流,字节输出流,字符输入流,字符输出流,前缀则代表了流的操作对象 6.在对文件的读写操作中,字节流可以读写二进制文件,字符流用来读写文本文件. 所谓二进制文件,指文件无字符编码格式,均由字节(Byte)组成,图片文件,word文档等均为二进制文件 文本文件,是一种特殊的二进制文件,也由字符组成,但需要通过特定的字符编码格式读取或写入,否则会出现乱码,可以用记事本打开的文件都是文本文件 使用字节流读取文件1.使用FileInputStream 步骤: 打开文件 按字节流读取文件 关闭文件 举例 例1 注意: read方法返回一个-1到255之间的一个整数,即一个字节,如果返回-1说明读到了文件尾 如果1.txt中为英文,可以在控制台显示,如果1.txt中有中文的话,控制台就会出现乱码,可见字节流在读取文本文件时的不足 例2 注意:FileInputStream效率较低,BufferedInputStream效率较高 使用字节流写文件1.使用OutputStream 步骤:开发文件,输出,关闭文件 举例 例1 注意:写入的是ASCII码值,文件不存在时会自动创建文件 例2 注意:FileOutputStream也存在性能问题,可以和BufferedOutputStream配合使用 文件拷贝1.举例: 使用字符流读写文件1.字符流的操作方法和字节流基本相同,字符流会根据当前的操作系统与语言环境选择适当的字符编码格式读写文件,适合读取文本文件,因为字符流会对文件内容进行编码,所以不适合用于读取二进制文件. 2.举例 例1 例2 注意:BufferedWriter提供了输出整行字符串的方法,需注意换行时使用newLine方法,而不是输出一个”\\n” 使用其他常用流1.对象输入输出流,ObjectInputStream和ObjectOutputStream能够针对对象进行读写操作 举例: 注意: 类必须实现java.io.Serializable接口才能将实例转换为流操作 通过writeObject方法可以将实现了序列化接口的类实例写入流中 通过readObject方法可以从流中将实现了序列化接口的类实例读取出来 2.字节输入输出流:InputStreamReader和OutputStreamReader能够通过制定的编码格式将字节流转换为字符流,并进行读写操作 举例: Properties类应用1.Properties是什么? java提供了Properties类简化配置文件的读写操作,Properties与HashMap相似,属于Map集合,适合读写键值对形式的配置文件 Properties中提供了load和store两个方法,方便从文件中读写集合的内容 举例:","link":"/1725226475.html"},{"title":"一起学java之异常简介","text":"前言程序运行中不可能一帆风顺,就算代码没有问题,也不能保证用户总是按程序员的意思输入,不能保证操作系统永远正常运转,网络永远通畅,如果程序中出现问题,不及时处理,程序会挂起会自动退出,程序的健壮性会大大降低 try_catch_finally1.我们已经见过的异常:两数相除,除数是0;数组越界;数字格式异常,空指针等等 举例: 语法 12345678910111213try{ //正常程序 }catch(异常类型 异常对象){ //异常处理 }finally{ //最后执行 } 说明: java中把可能出现异常的地方用try监控起来,如果程序运行中,try块中出现异常,则终止try块中其他语句的执行,转到catch块中执行相应的异常处理,如果try块执行正常,则不执行catch块中的语句 finally块中可以省略,如果有finally块中的语句,不管有没有异常,都会执行 java中追求万物皆对象,当然我们抓到的异常其实是封装了具体异常信息的一个对象 举例: 注意: 多重catch,当一段代码中可能有多种异常时,可以在同一个try块后使用多重catch,需要注意的是,父类异常应该尽量放在后面,否则子类异常就捕获不到了 java中的异常1.java中常见的异常可以在API文档中查到 2.java中的异常 3.说明: Throwable继承自Object,Error和Exception类用于处理java中的异常,Throwable,Error,Exception类的实例和他们子类的实例都被JVM识别为异常对象 Error和Error的子类被识别为致命的,程序无法修复的错误,很罕见,如VirtualMachineError,这类问题一般不希望用户的程序捕获他们,因此,一般不处理Error问题 Exception类型的异常被认识为可控制的异常,可以在程序中捕获处理,其子类RuntimeException称为运行时异常,该类异常通过程序员的努力,基本上可以避免 另外是非运行时异常,要求程序中必须用try_catch包围,程序在编译时就会检查是否对该类异常进行了处理,如果程序没有捕获非运行时异常,将无法通过编译 4.常见的异常 5.异常类的方法 java中的异常信息主要调用Throwable的几个方法进行处理,主要的方法有: printStackTrace():输出异常详细信息,包括异常原因,发生位置等 getMessage():返回异常详细信息,但是无法跟踪到行 说明:还有其他的一些方法,可以查阅API文档哦~~ 自定义异常1.系统定义的异常不能代表程序中所有的异常,有时需要自定义异常 2.自定义异常通常是可控的,只要继承RuntimeException类就可以了 throw和throws1.使用throw抛出异常 2.异常捕获或者throws抛出异常给调用者","link":"/1929845495.html"},{"title":"一起学java之面向对象的编程2","text":"final关键字1.final:最终的,final关键字在java中可以修饰类,成员方法,成员变量和局部变量 2.final修饰的类,表示”最终的类”,该类不能被继承,以前使用过的String类,System类,java.util.Scanner类都是被final修饰的 语法: 1public final class 类名{...} 举例: 3.final修饰的方法,不能在子类中重写 语法: 1public final 返回值类型 方法名 ([参数列表]){...} 举例: 4.final修饰的变量,其值将不能重新赋值,即称为常量 语法: 1public static final 变量类型 变量名 = 初始值; 举例: 注意,java中的常量一般由static final同时修饰,常量的命名一般使用大写字母,多个单词之间用下划线分割 抽象类1.抽象类是使用abstract修饰的类,包含没有方法实现的抽象方法,抽象方法也用abstract修饰 举例: 抽象的Pet类,有抽象的shout方法 继承Pet类的Cat类和Dog类,实现了shout方法 运行结果: 2.抽象类是为了实现多态,并优化继承结构的 3.抽象类可能只提供了一个类的部分实现,因此abstract类不能实例化 4.抽象类可以有成员变量,可以有一个或多个构造方法,但是这些构造方法不能被客户端调用来创建实例,抽象类的构造方法可以被其子类用super来调用 5.原则: 尽可能的不要从具体类继承 抽象类拥有尽可能多的共同代码,以提高代码的重用率 接口1.接口在现实生活中经常遇到，比如：电线插座和插头，螺丝帽的规格，电脑主板上的各种插槽等。接口就是规定了一系列的规格，标准，动作等，不做具体实现。 2.接口用interface来声明。一个类中如果不存在数据，只存在抽象方法时，就可以声明为接口。 接口声明举例： 用interface关键字声明接口。接口中的方法不能实现，接口中方法的默认修饰符是public abstract。 3.接口与类是并列的概念，类可以被继承，接口只能被实现，实现接口是用关键字implements，一个类同时可以实现多个类中的方法，实现多个接口时，接口之间用逗号分隔。 接口实现举例： 接口实现用implements关键字，类Cat实现了Pet接口，默认继承了Object类。接口中的所用方法必须全部实现，如果只是部分实现，该类就是抽象类。 4.抽象类和接口的比较 abstract class在java语言中表示的一种继承关系，一个类只能使用一次继承关系，但是一个类可以实现多个interface。 在abstract class中可以有自己的数据成员，非abstract的成员方法和abstract方法，而在interface中，只能够有静态的不能被修改的数据成员（也就必须是static final的，即常量），所有的成员方法必须都是public abstract的。 实现抽象类和接口的类必须实现其中的所有抽象方法，抽象类中可以有非抽象的方法（即实现了的方法），而接口中不能有方法实现。 一般情况下，在使用继承的时候，优先考虑定义接口，其次考虑定义抽象类。 枚举1.Jdk1.5以后，java引进了一个全新的关键字enum来定义一个枚举类。 2.枚举适用于一些数据具有若干特定值得场合，使用方法如同一个类 枚举定义举例 枚举使用举例 内部类1.定义在一个public类内部的类即是内部类，出于对一些类使用权限，数据安全，代码隐藏方面的考虑。 2.内部类可以分为成员内部类，局部内部类，嵌套内部类，匿名内部类等 内部类的使用举例1 内部类Bird，可以定义在Boy内部，定义在内部时，外部访问受到限制，有利于数据安全和代码隐蔽。内部类可以被static修饰，也可以被public修饰，但一般情况下内部类不使用public修饰，目的是为了内部类的安全性考虑。内部类可以像外部类一样使用。 内部类的使用举例2（匿名内部类） 在程序设计中，如果接口或者抽象类中需要实现的方法很少，临时使用接口或抽象类时，重新定义一个类单独实现方法又有些麻烦，可以直接使用匿名内部类对接口或者抽象类进行实现。 在匿名内部类中访问局部变量name，要求局部变量必须是final变量。 3.内部类降低了代码重用性，增加了代码的阅读难度","link":"/3922073342.html"},{"title":"一起学java之集合框架","text":"概述1.数组长度一旦确定,就无法更改,除非建立新的数组,比较浪费内存,操作不方便,java为我们提供了许多容器类 2.容器各有特点,使用时视情况而定 List1.List集合与数组的用途非常相似,但又有同 数组长途在使用前必须确定,一旦确定不能改变,而List集合长度可变,无需定义 数组中必须存放同一类型的数据,Lise集合中可以存放不同数据类型的数据 常用的的List集合有ArrayList,LinkedList和Vector,功能与用法基本相同,但内部实现不同 List集合已经重写了toString方法,可以将集合中的元素依次输出 插入情况多 就用LinkedList,随机访问多就是ArrayList 在插入的情况下LinkedList先是在双向链表中找到要插入节点的位置index；找到之后，再插入一个新节点。 ArrayList是基于数组,每次插入的时候都要调用System.arraycopy,该方法会导致重新计算索引 故而插入慢, 在随机访问时 ArrayList只要拿到下标就能拿到元素 ,LinkedList需要查找这个元素所在的位置 2.List集合中的常用方法 3.使用contains等方法时,应该重写类的equals方法,因为这些方法要调用equals方法类比较两个对象是否相等 Student类中重写了eauqls方法: 进行比较的结果: 4.ArrayList,LinkedList和Vector的区别 Vector为线程安全的,ArrayList和LinkedList非线程安全,Vector性能稍微逊色 ArrayList用数组实现,添加大量数据,插入数据等时,效率稍微逊色,但按下标查找时效率很高 LinkedList使用链表实现,添加,插入,删除元素时只需对相邻元素进行调整即可,效率很高,但按下标查找时效率较低 一般来说,ArrayList保存经常用来查询的数据,LinkedList适用于保存经常进行修改操作的集合 Set1.Set集合与List集合的很多用法是相同的,但Set集合中的元素是无序的,唯一的,常用的Set集合为HashSet 2.常用方法,与List基本相同,不再赘述 3.Set集合的迭代 使用Set的iterator()方法类获取迭代器对象,迭代器是Iterator类的实例 使用迭代器的hasNext()方法判断集合中是否还有元素,配合while循环来迭代 使用迭代器的next()方法取得集合中的元素 4.Set存储基本类型(自动装箱成包装类)和字符串时是不会重复的,但存储我们自定义的类的对象时会出现重复的数据,是因为Set根据hashCode来判断存储位置,如果hashCode 相同,再根据equals方法比较,但我们在没有重写hashCode方法时,对象在内存中的地址不同,会返回不同的hashCode,故会出现两个对象数据一样,但由于hashCode不同而被重复记录在Set中的情况,此时,我们需要重写hashCode方法,使数据相同的对象返回相同的hashCode. 重写hashCode方法: 运行结果: 在编写java程序中,hashCode和equals这两个方法有这样的规律: hashCode()方法返回值相同时,equals()方法比较不一定相等 equals()方法比较相等时,hashCode方法返回值是相同的 Map1.通过List集合存储元素之后,如果想获取某一个特点的对象,操作比较繁琐,需要遍历List,此时我们可以使用Map 2.Map以键值对的形式存储数据(key–&gt;value) 3.常用的Map集合为HashMap和Hashtable HashMap的常用方法 Map集合中key的维护是依靠Set集合,故key不能重复,添加key相同的映射关系时,后面添加的映射关系会覆盖前面的映射关系 HashMap和Hashtable的主要区别: Hashtable是线程安全的,HashMap是非线程安全的,HashMap比Hashtable的性能更高 Hashtable不允许使用null值作为key或value,但是HashMap是可以的 举例: Collections工具类1.Collections类与Arrays类一样都提供了一系列静态方法,只是Arrays主要操作数组,而Collections主要操作List集合,同时还有对Set的相关操作 2.Collections类提供了一系列的静态方法,可以使用类名.方法名直接调用 常用方法 在List中查找一个对象时,该对象必须实现Comparable接口 泛型(Generic)1.集合中要求装入的是Object类型的对象,故在拿到对象使用的时候要强制类型转换 2.泛型可以使集合在实例化时就规定好将来要装入什么类型的对象,从集合中取出元素时,不再需要强制类型转换 举例: 3.自定义的类也可以使用泛型 举例: 结果:","link":"/8847.html"},{"title":"一起学java之jdk常用工具类","text":"Date1.Data类位于java.util包中,表示时间 2.Date该类包装了一个毫秒值,表示从1970年1月1日00:00:00 GMT开始到现在毫秒数 3.Date类的两个常用构造方法 Date(),按照当前系统时间创建一个Date对象 Date(long date),按照给定的时间毫秒值创建一个Date对象 4.主要的方法 举例: SimpleDateFormat1.使用SimpleDateFormat类来格式化时间,使之成为自己想要的格式 举例: 说明：yyyy表示年，MM表示月，dd表示日，HH表示24小时制的小时数，hh表示12小时制的小时数，mm表示分钟，ss表示秒 2.如何将字符串对象转换成Date对象? 使用SimpleDateFormat的parse()方法 举例: NumberFormat1.数字格式化也是在程序中常用的技巧,主要是对小数位数,表示形式等的格式化2.NumberFormat使用getInstance()方法实例化3.可以使用NumberFormat进行数字格式化 4.也可以使用Decimalformat进行数字格式化 注意: #:代表一个位置数字,如果该位置数字不存在,则不显示 ,:代表数字中的分割符 0:代表一个数字位置,如果该位置不存在,则用0来补充,小数中多余的部分四舍五入 .:代表小数点 E:科学计数法 %:用百分号表示数字 Calendar1.用来记录日期的日历类Calendar 2.使用getInstance()方法实例化 3.常用方法: 使用时请注意星期,月份等与实际值之间的差异 4.Calendar与Date的转换 Calendar转化为Date 123Calendar cal=Calendar.getInstance(); Date date=cal.getTime(); Date转化为Calendar 12345Date date=new Date(); Calendar cal=Calendar.getInstance(); cal.setTime(date); Math1.java.lang.Math类包含了许多常用数学运算,全部为静态方法 2.方法举例: 3.两个常用的常量,Math.E和Math.PI分别表示自然对数的底数和圆周率 4.还有其他方法,使用时勤查API文档即可","link":"/55382.html"},{"title":"一起学java之面向对象编程1","text":"static修饰符1.static,静态 在java中,static用来修饰类的成员变量,方法等 static修饰类的成员变量,称为类的静态变量,static修饰类的方法,称为静态方法 在程序运行时,第一次加载类的时候,初始化静态变量,静态变量会一直到应用程序结束才被系统销毁 静态变量不依赖类的某一个实例,所有的实例共享同一份静态变量 静态方法也不依赖类的某一个实例 2.静态变量和静态方法的调用 语法: 123类名.静态变量名; 类名.静态方法名(); 由于静态变量被所有的对象共有,因此在一个对象中改变静态变量,其他的对象中也会看到变化 举例: 3.比较静态变量和成员变量 4.比较静态方法和普通方法 5.静态代码块 静态代码块可以使类在第一次加载后进行一些操作,一般情况下用来初始化静态变量 语法 12345static{ //语句块 } Object Oriented OO:Object Oriented,面向对象 OOA:Object Oriented Analysis,面向对象的分析 OOD:Object Oriented Design,面向对象设计 OOP:Object Oriented Programming,面向对象的编程 面向对象最大的特点是,程序研发人员可以根据具体的问题,设计出任何需要的类,用来解决问题.面向对象是一种思想!!! 封装1.封装将对象的属性和方法结合在一起,统一提供对外的访问权限,分装可以将类的使用者和设计者分开,设计者可以决定哪些内容可以提供给使用者,使用者在使用的时候不需要了解设计者是如何实现的 2.在java中,类把数据和方法封装到一起,对数据和方法操作起到一种保护作用. 3.用public,private,protected来控制对属性和方法的访问 4.控制权限的修饰符 public 即公开的,用public修饰的属性和方法,其他任何类都可以访问 private 即私有的,用private修饰的属性和方法,其他任何类都不能访问,只有在当前类内部才可以访问 protected 即表示受保护的,用protected修饰的属性和方法,允许相同包中的其他类(包括子类)或非相同包的子类访问 缺省修饰符 缺省修饰符的属性和方法允许相同包中的其他类进行访问,不允许其他包中的类(包括子类)访问 5.一般情况下,属性用private修饰,并为private修饰的属性提供一组get/set方法(属性访问器). 6.public修饰符还可以用来修饰类,可以用来修饰类的修饰符如下: 方法重载(Overload)1.System.out.println()方法是重载过的 2.在同一个类中,一个方法名称可以定义多个方法,只要方法参数列表不同即可,这叫做方法的重载 3.方法重载要求方法名相同,方法参数列表不同,方法的参数列表不同包括 方法参数的数量不同 方法参数的类型不同 相同数量参数中,不同参数类型在方法参数列表中的顺序不同 继承(extends)1.事物之间可能存在包含与被包含的关系,程序中设计出的类也会有这种关系.java中使用继承机制描述这一关系,被继承的类称为父类,继承父类的类,称为子类.继承可以减少代码量,方便维护,使程序更符合实际,更符合人的思维习惯 2.java中继承使用extends关键字实现,子类继承父类的属性和方法(构造方法除外), 3.构造方法不能继承,因此继承的子类在默认情况下只有一个无参构造方法 4.在java继承中,子类可以访问父类的public,protected修饰的属性和方法,不能访问父类中private修饰的属性和方法;如果子类与父类不在同一个包中声明,那么父类中使用缺省修饰符的属性和方法在子类中也不能被访问. 权限修饰符总结 总结： propected，在同包和子类中访问 default，在同包中访问 5.子类继承后可以重写父类的方法(Override),方法重写必须满足如下要求 重写方法和被重写方法必须具有相同的方法名 重写方法和被重写方法必须具有相同的参数列表 重写方法的返回值类型必须和被重写方法的返回值类型相同或者是其子类 重写方法的不能缩小被重写方法的访问权限 6.在new子类对象时,首先会调用父类默认无参的构造方法,再调用子类的构造方法,但可以通过super关键字,指定使用父类的某一个构造方法,但super要出现在构造方法的最前面,否则报错. super关键字,指向父类对象 7.Object类 java中,Object类是所有类的父类,所有类默认继承Object类,都具有Object类的方法和属性 Object类能够被外界访问的,常用的方法有: 关于toString方法 System.out.println()方法可以传入任何参数,包括基本类型和引用类型 当用System.out.println()输出一个对象时,首先调用该对象的toString()方法 Object类的toString()方法默认输出对象的内存地址 经常在类中重写toString()方法. 关于equals()方法 equals()方法默认比较两个对象的地址 如需比较两个对象的内容,需要重写该方法,实际应用中,经常需要重写该方法 String类已经重写了该方法 多态(polymorphic)1.多态:同一种事物,同一种方法,由于条件或环境不同,产生的结果也不同 2.方法重载即是多态,称为设计时多态 3.在java中,把子类的对像赋值给父类,用父类的引用调用方法的时候,具体执行方法的是子类的对象,也是一种多态形式,称为运行时多态 举例: Shape类,有计算面积的area()方法 Circle类,继承Shape,重写area()方法 Square类,继承Shape,重写area()方法 结果","link":"/24774.html"},{"title":"一起学java之方法","text":"为何要使用方法1.事物都是由自身的属性和行为构成的,对象所能完成的行为,即方法. 2.将相同的操作定义为方法,可以方便代码重用,方便程序的扩展 3.调用方法的时候,不需要知道方法内部的具体实现,便于封装 方法的定义和使用1.程序设计中,方法是为了完成某一独立操作的若干条语句的组合. 2.方法的定义 12345[修饰符] 返回值类型 方法名称([参数列表]){ //方法体 } 方法的修饰符:方法的修饰符是可选的,main方法的修饰符是public static,代表公开的,静态的.方法的修饰符将在以后的章节中介绍 方法的返回值类型:方法是一系列动作的组合,动作执行结束后可能会产生一个结果供其他程序使用,需要在方法定义时指定返回结果的类型,即方法返回值类型,main方法中没有返回值,返回值类型被定义为void 方法的名称,不需赘述,但请注意方法的名称遵循标示符的的命名规则,建议使用动词或动宾短语,首字母小写,驼峰式 方法的参数列表,方法的名称后面紧跟着一个小括号,小括号中的内容称之为方法的参数,方法的参数可以为零个或者多个,详细内容在下面的章节介绍 方法体,大括号之内的语句块称之为方法体 3.方法的使用 方法的调用语法 一般性的用法,静态方法与此略有不同 同一个类中的方法可以不用”.”直接使用(本质上是使用了”this.”) 1对象.方法名([参数列表]); 方法的返回值1.要使方法对程序产生影响,方法给调用者一个返回值是必要的 2.定义方法的时候,必须指定返回值类型,无返回值时,返回值类型为void 3.方法体内必须用return返回相应的返回值,返回值返回给方法的调用者 4.无返回值的情况下(void),本质上是使用了return关键字结束方法,只是通常该语句省略了,return的作用是结束方法并返回,在方法执行过程中,只要遇到return就会结束方法并返回 5.如果方法有返回值,那么在调用的时候,就可以用变量来接受该返回值,变量的类型即是方法定义时的返回值类型 举例: 方法的参数1.要使方法能够更加灵活的根据调用者的要求执行动作,调用者给方法一定的参数是必要的 2.参数列表用来向方法传入参数,需要指定参数的类型和名称,与变量定义的语法相同 举例: 3.带参数的方法的调用 带参数的方法在调用时需要传入参数,举例: 一直在用的println()方法就是一个需要参数的方法,我们常常传入一个String型的字符串 传入的参数必须是方法定义时指定的类型,参数顺序与定义时参数列表的顺序相同 方法中是由num1减去num2,所以最终的结果是由10减去1的值,而不是1减去10 如上面的例子,程序运行中,方法参数列表中定义的num1和num2称为形式参数,在实际调用方法时传入的参数,10和1,称之为实际参数 注意: 实参对应的形参数量一致 实参对应的形参数据类型一致 当调用没有参数列表的方法时,方法后的()不能省略 参数列表的设计要根据实际情况来定,参数太多,调用不便,参数太少,方法不灵活 使用方法的目的是为了代码重用,因此设计时方法尽可能功能独立 4.方法的可变参数 定义举例 注意: 可变参数适用于参数个数不确定，类型确定的情况，java把可变参数当做数组处理 可变参数必须位于参数列表的最后,一条参数列表中只能有一项可变参数 调用可变参数的方法时，编译器为该可变参数隐含创建一个数组，在方法体中以数组的形式访问可变参数 可变参数方法的使用 基本数据类型和引用数据类型作为方法的参数1.基本数据类型作为方法的参数时,形参在方法中发生改变,不会影响实际参数的值 2.引用类型作为方法的参数时,形参在方法中发生改变,会影响到实际参数的值(String除外) 变量的作用域和生命周期1.变量的作用域是指一个变量在定义后,在程序的什么地方可以使用它 2.之前说过:变量的作用范围,在申明他的{}内有用,出了{},没有人认识它 3.判断语句和循环语句中定义的变量,在当前的判断语句或循环语句的大括号之内有效;方法中定义的变量(局部变量),只能在当前方法使用;成员变量,对象实例化后可用,对象销毁后,内存也随之销毁,变量随之不可用 4.方法内的局部变量(包括方法参数),如果与成员变量同名,方法中优先使用局部变量,这种情况下如果要使用成员变量,需要使用this关键字,this用来指向当前类的当前对象 构造方法 1.构造方法是用来给new 关键字调用的,用来实例化对象,new关键字会在堆内存中开辟空间 2.构造方法没有返回值,名称与类名相同 3.系统默认为每个类提供无参的构造方法 4.可以在构造方法中传入参数,在实例化对象时为对象的属性赋值 5.如果提供了带参数的构造方法,系统不在默认提供无参构造方法,这时如果需要使用无参构造方法,需要人为提供","link":"/1067981242.html"},{"title":"一起学java之类与对象","text":"万物皆对象1.我们能感受到的万事万物都是一个个对象,都属于某一个类型 2.对象具有各种各样的属性,同时也拥有各种各样的行为 3.把一系列对象的共同特征和行为抽象出来,形成一个概念模型,就是类;也就是说:类是对象的抽象定义,对象是类的具体实例 4.面向对象程序的本质就是:将程序设计成一个一个的类,定义出他们的特征和行为(即属性和方法),然后根据类创建出一个一个具体的对象,利用对象之间的关系进行调用,完成一系列的任务 类的定义1.java程序以class为组织单位 2.关键字class用来定义类 3.定义类的语法 12345678910111213141516171819202122232425[类修饰符] class 类名 { //定义属性部分 [属性修饰符] 属性1的类型 属性1; [属性修饰符] 属性2的类型 属性2; … [属性修饰符] 属性n的类型 属性n; //定义方法部分 方法1; 方法2; … 方法m; } 4.注意: 定义一个类的步骤:定义类名,编写属性,编写方法 class是定义类的关键字 类的命名规则,即标示符的命名规则,但为了阅读理解方便,约定不使用_,$等特殊字符,类名通常是名词性质,首字母大写,驼峰式 属性的定义,与局部变量的定义相同,定义在类体内,方法体外,与方法平级,即全局变量 有一点需要强调的是,类的属性,即全局变量,可以不初始化,在使用时,系统会默认初始化,整数均默认为0,小数默认为0.0,char默认为空格,boolean默认为false,引用类型默认为null 方法的定义,使用动词或动宾形式的短语,首字母小写,驼峰式命名 5.例子:定义一个学生类 如何创建和使用对象1.定义类,实际上就是定义了一个新的数据类型,根据基本数据类型可以声明变量,自己申明的类也可以声明变量,称为对象 2.声明一个对象的语法 1类名 对象名; 3.声明后并没有给对象分配内存空间,要分配内存空间,需要使用new关键字 1类名 对象名 = new 类名(); 声明对象并分配内存空间,即为类实例化(从一个抽象的类中具体中一个具体的实例) 4.实例化对象后,可以访问对象的属性和方法 123对象名.属性名 对象名.方法名([参数列表]) 实例化一个Student类的对象,并且赋值,调用方法: 5.注意: 一个类可以实例化出多个对象,不同的对象在内存中是独立的,改变一个对象不会影响其他的对象 上面我们看到的例子中,我们在main方法中根据自己定义的类声明了一个局部变量,事实上还可以声明成员变量 使用类和对象的优点1.与人类的思维习惯一致,把人类解决问题的思维过程转变为程序能够理解的过程 2.提高了程序的可重用性,一个类可以创建多个对象实例，增加了重用性 3.信息隐藏，提高了程序的可维护性和安全性 ,封装实现了模块化和信息隐藏 ,封装使得在对象外部不能随意访问对象的属性和方法(在学习了方法之后详细体会) 打包和导入1.打包 观察package语句 1package com.phome.java.test1; 注意 允许类组成较小的单元(类似文件夹),易于找到和使用相应的文件,方便管理 防止命名冲突 更好的保护类属性和方法 包名之前最好加上唯一的前缀,通常使用组织倒置的网络域名 一个类只能有一条package语句 2.导入 为了使用不在同一个包中的类,java使用import关键字导入 观察import语句 123import com.phome.java.test2; import java.util.*; 系统包和自己定义的包 使用”*”导入一个包中所有的类","link":"/3376612127.html"},{"title":"一起学java之String简介","text":"基本概念1.String是一个类型,用来存储一串字符的,本质上是一个char类型的数组 2.String类在java.lang包中,lang包已经默认导入,我们不需要再用import导入了 3.定义及赋初始值 123String 变量名 = &quot;初始值&quot;; String 变量名 = new String(&quot;初始值&quot;); 第二种方法不常用,推荐使用第一种 4.字符串可以进行”+”运算,作用是连接两个字符串,也可以将字符串与基本类型的变量进行”+”运算,系统会自动将基本类型的变量转换成字符串进行连接操作 5.内存中的字符串,字符串的intern()方法,字符串比较 6.注意: 内存中的字符串,注意代码中没有new的字符串字面常量会在编译时编译进字符串池中 intern()方法,返回字符串在字符串池中的位置,或者向字符串池中注册 对于引用类型,==比较地址是否相同,equals()比较内容是否相同 一些操作1.常用的方法 方法名称 返回类型 作用 length() int 获取字符串长度 charAt(int) char 获取字符串中的一个字符 indexOf(String) int 返回传入字符串在原字符串中第一次出现的位置 startWith(String) boolean 判断原字符串是否以传入字符串开始 endsWith(String) boolean 判断原字符串是否以传入字符串结束 toUpperCase() String 变大写 substring() String 截取字符串 trim() String 去前后空格 split() String[] 原字符串按特定字符串分割成一个字符串数组 … … … 字符串与基本数据类型的转换1.基本类型装换为字符串,用一个空字符串”” 与基本类型的变量相加 2.基本类型转换为字符串,使用String的ValueOf方法 3.字符串转换为基本类型,使用各类型的包装类,char使用字符串的charAt()方法 基本类型 包装类型 转化方法 int Interger parseInt(); byte Byte parseByte(); short Short parseShort(); long Long parseLong(); float Float parseFloat(); double Double parseDouble(); boolean Boolean parseBoolean(); StringBuffer和StringBuilder1.StringBuffe在对字符串操作时效率要远高于String 2.StringBuffer与StringBuilder用法相似,但StringBuffer线程安全,推荐使用 3.StringBuffer的insert();append();delete()方法","link":"/56445.html"},{"title":"一起学java之数组","text":"数组的定义1.什么是数组: 数组是一个引用类型的变量,存储相同数据类型的一组数据 2.什么是声明变量 声明数组 声明一个变量就是在内存空间划出一块合适的空间 声明一个数组就是在内存空间划出一串连续的空间 3.数组的结构和基本要素 标示符:数组的名称,用于区分不同的数组 数组元素:在数组中存放的数据 元素下标:对数组元素进行编号 元素类型:数组元素的数据类型 使用数组1.声明数组的语法 12数据类型 数组名[]; 或者 数据类型[] 数组名; 2.注意: 推荐使用后一种语法 数据类型可以是基本数据类型,也可以是引用数据类型 数组名遵循标示符的命名规范,建议使用名词的复数形式 数组在声明时无法指定数组长途,因为数组声明在栈内存中 3.举例 4.给数组分配空间的语法 1数组名 = new 数据类型[数组长度]; 注意: 数组声明后,并没有为它分配存储空间,要存入数据,必须要先分配存储空间 给数组分配内存使用new关键字,会在堆内存中分配相应的空间 数组的内存空间分配之后,长度无法改变,如果重新定义,会将之前的数组删除,建立新的数组 如下图第一句在堆内存中新建了一个长途为5的int类型的数组,并且赋值给nums 第二句重新在堆内存中新建了一个长度为7的int类型的数组,赋值给nums,之前的数组在堆内存中销毁了 5.数组赋值 12345数据类型[] 数组名 = {数组元素}; 或 数据类型[] 数组名 = new 数据类型[]{数组元素} 或数组名[数组下标] = 数据值 数组的应用1.求最大值 原理,定义变量max,使用max和数组中的所有元素挨个比较,如果有元素的值大于max,就使max的值等于该元素的值,这样经过一轮比较够,max的值便是数组中最大的那个值. 算法举例(假设数组名为a): 2.冒泡排序 原理,讲n个数从小到大排列,可以在第一次循环中找出最大的数放在数组的最后位置,在第二次循环中找出第二大的数放在数组的倒数第二个位置,…….,n-1次循环后,数组即从小到大排列了 算法举例 再谈基本数据类型和引用数据类型1.java的内存是怎样的 Heap(堆,new出来的东西) stack(栈,局部变量) data segment(静态代码区,静态变量,字符串常量) code segment(存放代码) 2.基本数据类型:对于基本数据类型,不同的变量会分配不同的存储空间,改变一个变量的值不会影响其他变量的值; 3.引用数据类型:对于引用数据类型,不同的变量可能会指向同一块内存地址,改变一个变量的值可能会影响其他变量的值 二维数组1.二维数组的每一个元素是另一个数组,本质上是指向另一个数组的引用2.一维数组的内存结构 3.二维数组的内存结构","link":"/58759.html"},{"title":"一起学java之Java语言程序结构","text":"前言: 程序想要完成更加强大的功能,只有流线型的顺序结构是不行的. 程序存在 顺序结构, 分支结构, 循环结构 这三种结构! 结构简介1.顺序结构:按顺序执行 2.分支结构(如图): 3.循环结构(如图): 选择结构:if语句1.语法: 12345if(条件表达式){ 执行代码; } 2.结构: 3.当条件表达式为真的时候,执行{}中的代码 4.当执行代码只有一句时,可以省略{} 选择结构:If-else和if-else if-else1.语法: 123456789if(条件表达式){ 执行代码A; }else{ 执行代码B; } 12345678910111213if(条件表达式1){ 执行代码A; }else if(条件表达式2){ 执行代码B; }else{ 执行代码C; } 2.结构 3.注意 注意代码的结构,做好缩进可以更容易的看出if,else的对应关系 if语句可以嵌套 4.例子 如何判断是否为闰年 逻辑:整百的年份可以被400整除,为闰年,否则不是,其他年份被4整除为闰年,否则不是 代码演示: ![](/images/is_run_year_code.png) 选择结构: 三元表达式1.语法格式: 1(关系或者逻辑表达式)? 成立时的返回值:不成立时的返回值; 2.例子 简化后判断是否为闰年 ![](/images/simplify_is_run_year_code.png) 3.注意: 虽然能简化代码,但是会提高代码的阅读难度,不建在复杂逻辑中议使用. 选择结构:switch-case1.语法: 12345678910111213141516171819202122switch(表达式){ case 值A: 代码段A; break; case 值B: 代码段B; break; default: 代码段F;} 2.注意: 表达式的值会与case子句中的值比较,如果相等则执行子句中的代码段,知道遇到break为止 如果代码段中不写break,会执行后续case子句中的代码,即代码穿透现象 如果没有case子句中的值与表达式的值相等,则执行default子句中的代码,default子句类似于else的作用 循环结构:while循环1.语法: 12345while(循环条件){ 执行代码块.称之为&quot;循环体&quot;; } 2.while循环的结构 3.while循环的执行顺序 : 程序进入循环前,首先判断循环条件是否为true 如果循环条件为true,执行循环体中的代码,之后返回步骤1 如果循环条件为false,跳过循环体执行后面的代码 4.注意: 循环条件是一个boolean类型的表达式,决定了什么条件下执行循环,什么条件下不执行循环 为了避免死循环,一定会有循环变量,循环变量参与循环条件的判断,并且循环变量的值会在循环体内发生改变 循环结构:do-while循环1.语法: 12345do{ //执行代码; }while(循环条件) 2.结构 3.do-while循环的执行顺序 执行循环体 判断循环条件 如果循环条件为true,返回步骤1 如果循环条件为false,结束循环,执行后面的代码 4.注意: while循环中,首先判断循环条件,之后执行循环体;do-while循环中,先执行一次循环体,再判断循环条件 do-while循环的循环体至少会被执行一次 循环结构和分支结构可以嵌套,嵌套时注意大括号”{}”的匹配 循环结构:for循环1.语法: 12345for(表达式1; 表达式2; 表达式3){ //循环体 } 2.结构 3.for循环执行顺序 3.1.执行初始化部分 3.2.进行循环条件判断 3.3.根据循环条件判断结果,决定是否执行循环 3.4.执行迭代部分.改变循环变量的值 3.5.重复2,3,4部分,直至循环条件不成立 4.注意: 不要出现死循环 一般的,循环次数确定的可以选择for循环,循环次数不确定可以选择while循环 for循环,do循环,do-while循环,分支选择语句可以相互嵌套 跳转语句break和continue1.break:如果在循环体中遇到break语句,会立刻跳出当前循环,继续执行后面的代码 2.continue:如果在循环体中遇到continue语句,会立刻跳出本次循环,执行下一次循环","link":"/5002.html"},{"title":"一起学java之变量,数据类型和运算符","text":"标示符1.概念:就是标示变量,类等的名称的字符串序列 说白了就是程序中可以自己起名字的地方 2.标示符的命名规则 由字母,下划线_,美元符号$或数字组成 由字母,下划线_,美元符号$开始 大小写敏感,长度无限制 不能使用java关键字,goto和const虽然未被使用,但java也作为关键字保留 不合法的标示符举例:class data# 78.9 3.约定:起名要做到”见名知意” 常量1.字面常量:我们所能看到的真实的字面值 整型字面常量:10,123 浮点型字面常量:3.14 布尔型字面常量:true,false 字符型字面常量:’a’,’A’ 字符串型字面常量:”gansu” Null型字面常量:值为null,代表什么都没有 2.在另一种语境下,常量的意思是值不可改变的变量,用final修饰,以后会遇到 变量1.概念:变量是程序中最基本的存储单元,实质是内存中的一小块区域,可以使用变量名来访问该一小块内存区域 2.变量的定义和使用:变量先定义—&gt;再赋值—&gt;再使用 [] []1234567891011类型 变量名 [= 初始值]; int a = 30; int b = 40; int c = a * b; int d; d = 50; float f = 12.5f; String s = \"Hello\"; boolean choice = true; System.out.println(s); 3.数据类型的概念:因为在变量中存储数据时会遇到各种各样的数据,所以有必要将不同的数据按照数据类型分开,方便分配内存空间和使用4.变量的作用范围,在申明他的{}内有用,出了{},没有人认识它5.变量的分类 按变量申明的位置划分 局部变量:方法或语句块内部定义的变量 成员变量:方法外部,类的内部定义的变量 按数据类型划分 基本数据类型的变量 引用数据类型的变量 基本数据类型1.java语言提供了8种基本数据类型 2.说明: byte型,占用1个字节,对字节操作时使用,如文件读写等 short型,占用2个字节,保存较小的整数时使用 int型,占用4个字节,保存一般的整数时使用 long型,占用8个字节,保存较长的整数时使用 float型,占用4个字节保存小数时使用 double型,占用8个字节,保存精度较高的小数时使用 char型,占用2个字节,保存单个字母或汉字时使用 boolean型,占用1个字节,保存逻辑值,如性别,婚否等 类型定义好之后,后续无法改变,所以定义变量时要根据实际情况选择好变量的数据类型 3.特殊字符的说明,char类型可以保存一个字符(字母或汉字),一些特殊字符在保存时可以采用转义字符”&quot;: [] []123456char a = '\\n'; //换行 char b = '\\\\'; //反斜杠 Char c = '\\''; //单引号 4.注意java会默认将整型的字面常量认作int类型,将浮点型的字面常量认作double类型,申明long类型时要在后面加L,申明float类型时要在后面加F 5.一个特殊的类型：String类型。 String并不是java的基础数据类型,不过是一个很常用的类型,用来存储字符串变量。 运算符如果说数据类型是编程语言的砖瓦,那么运算符和操作符则是编程语言的石灰和水泥了,它是将各种数据类型的值有机组合的糅,使得数据值不再只是一个孤立的值,而有了一种动态的灵性. 1.赋值运算符和常见算数运算符 运算符 说明 示例 = 赋值运算符,为变量赋值 int a = 3; + 加法运算符,求两个操作数的和 3+2,表达式的值为5 - 减法运算符,求两个操作数的差 6-1,表达式的值为5 * 乘法运算符,求两个操作数的积 2*3,表达式的值为6 / 除法运算符,求两个操作数的商 8/4,表达式的值为2 % 求余运算符,求两个操作数相除后的余数 9%5,表达式的值是4 ++ 自增运算符,对一个整数变量执行+1的操作 int a = 3;3++或++3的值都是4 – 自减运算符,对一个整数变量执行-1的操作 int a = 3;3–或–3的值都是2 2.求余运算符要求两个操作数均为整数,但测试的结果好像浮点型的也可以,不重要. 3.注意整除和浮点除的区别:两个操作数全是int型,结果也是int型,会丢失小数部分, 4.注意++和–运算,a++表示先使用a的值,再给a加上1;++a表示先给a加上1,再使用a的值,–与此类似 5.是时候扩展我们程序的功能了,看看Scanner类,注意Scanner对象的一些常用方法,如nextInt() 6.关系运算符 == != &gt; &gt;= &lt; &lt;= 等于 不等于 大于 大于等于 小于 小于等于 7.逻辑运算符 运算符 操作数 运算规则 逻辑与&amp;&amp; 2 两个操作数均为true,则结果为true,否则结果为false 逻辑或|| 2 两个操作数中只有一个为true则结果为true,否则结果为false 逻辑非! 1 操作数为true则结果为false,操作数为false则结果为true 8.在逻辑与&amp;&amp;运算中,当第一个操作数返回false,直接返回false,不再进行第二个操作数的运算;在进行逻辑或||运算时,当第一操作数返回true,直接返回true,不再进行第二个操作数的运算 9.复合赋值运算符(假设a = 10) 表达式 等价的java代码 运行的结果 a += 3; a = a + 3; 13 a -= a /= 3; a = a / 3; 3 a %= 3; a = a % 3; 3 10.运算符的优先级 注意:千万不要去记这个,有个印象就行,实际写代码的时候请使用(). 优先级 运算符 1 () [] . 2 ! +(正) -(负) ~ ++ – 3 * / % 4 +(加) -(减) 5 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 6 &lt; &lt;= &gt; &gt;= instanceof 7 == != 8 &amp;(按位与) 9 ^ 10 | 11 &amp;&amp; 12 | | 13 ?:(三元表达式) 14 = += -= *= /= %= &amp;= 数据类型转换1.自动数据类型转换 java基础变量按照分配内存空间从小到大的顺序排列,如图 在一个表达式中,如果含有不同数据类型的数据,自动按照从左向右,从下向上的顺序转换类型 请注意表达式结果的数据类型 boolean类型不参与数据类型转换 低级别的数据类型可以轻松的转换为高级别的数据类型 2.强制数据类型转换 同一级别,高级别向低级别的数据类型转换,需要强制 转换过程中会丢失数据 字符串String与其他数据类型用 +号连接时,都会将其他数据类型先转换为String,然后两个字符串拼接","link":"/558044812.html"},{"title":"一起学java之jdk的安装","text":"Java的历史1.1991年,sun公司,”Green”项目,智能家电,JGosling(詹姆斯·高斯林),C++ —&gt; Oak(橡树)起初濒临”倒闭”,internet开始流行 2.94年,Oak改名java(印度尼西亚爪哇岛,盛产咖啡,咖啡宝贝),开发了HotJava浏览器,95年java正式推出发布 3.java具有能够跨平台,面向对象等特性,sun又将java设计为可以针对不同应用场景的综合开发平台,使之快速流行 4.学习了java基本语言特性后,可以学习不同的开发包,进行不同平台的开发 Java SE:桌面应用开发 Java EE:企业级开发 Java ME:移动平台开发(手机等) J2SE1.1 —-&gt; J2SE1.5 改名 java SE 5.0 09年,甲骨文收购sun,取得java版权 如今免费版本止步与第８版 java的优势1.面向对象—-使之特别适用用复杂,庞大的应用软件开发 2.平台无关—-代码不用修改即可应用于不同的平台 3.健壮,安全—-完善的内存管理机制 开发前准备(安装配置JDK)1.安装jdk 首先下载一个jdk,去官网找(注意sun被oracle收购了,应该去oracle的官网) JDK 全称为Java Development Kit ,即java开发工具包．JRE 全称为Java RunTime Environment ,即java运行时环境 ,JDK中即包含一个JRE bin目录下存放了运行,编译,调试java程序的必需的各种可执行文件 lib目录下是java的各种开发类库 配置环境变量1.鼠标右击我的电脑–&gt;属性–&gt;高级系统设置–&gt;环境变量 JAVA_HOME=C:\\Program Files\\Java\\jdk1.7.0_21; CLASSPATH=.;%JAVA_HOME%\\lib;(注意不要忘了代表当前目录的 .; ) Path=原变量值;%JAVA_HOME%\\bin;(注意不要删除以前的值) 命令行输入java和javac命令进行验证 java的运行机制(简单) java运行平台,即java虚拟机(java Virtual Machine),不同的平台有不同的JVM,不同的JVM可以运行相同的.class文件这样,java即做到了跨平台,可以”Write once , run anywhere”. HelloWorld1.第一个java小程序 使用IDEA,新建一个Hello.java文件 输入以下代码 2.一些说明 java严格区分大小写,请注意大小写字母 //单行注释,注释的内容在编译的时候忽略,只是为了自己阅读方便 关键字class声明了一个类,名称为Hello,public修饰该类为公有,java中要求公有类的名称和文件名必须相同,且一个.java文件中只有一个公有类 main方法是java程序的入口,程序从这里开始运行 System.out.println();用于在控制台输出语句,输出后换行,没有末尾的System.out.print();为不换行输出,可以使用\\n换行 执行语句在方法体内,用{}包括,方法在类中,用{}包括 括号必须成对出现,一行只写一条语句,注意代码的缩进和建筑美","link":"/3105940755.html"}],"tags":[{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"nexus","slug":"nexus","link":"/tags/nexus/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"spring","slug":"spring","link":"/tags/spring/"}],"categories":[{"name":"一起学java","slug":"一起学java","link":"/categories/一起学java/"},{"name":"玩转spring","slug":"玩转spring","link":"/categories/玩转spring/"}]}